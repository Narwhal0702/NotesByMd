# JavaScript

## JavaScript基础

* JavaScript没有重载，如果定义了两个名字相同的函数，后面的会覆盖前面的
* 基本类型是简单的数据段，引用类型指那些可能由多个值构成的对象。复制引用类型值时会将存储在变量对象中的值复制一份放到为新对象分配的空间中，不同的是这个值的副本实际上是一个指针，引用的是堆中的同一个对象，因此改变其中的一个变量就会影响另一个值的相同变量
* 检测值类型typeof，检测引用类型的值instanceof

#### for,for...in,for...of区别

* for...in:可以用来枚举对象的属性，for(let key in object){} 此处let操作符不是必需的，这是为了保证使用局部变量

#### break和continue区别
* break语句会立即退出循环，强制继续执行循环后面的语句
* continue退出循环后会从循环的顶部继续执行，也就是跳过当次循环

#### 对象属性的访问

* 一般使用点表示法和方括号表示法，使用方括号表示法时应将要访问的属性以字符串的形式放在方括号中
* 方括号表示法的主要优点是可以通过变量来访问属性，但一般建议使用点表示法

## Array类型

* 构造时可以省略new操作符
* 通过设置length属性的值可以实现向数组末尾移除项，或添加新项undefined
* api：
  * Array.isArray(value):检测某个值是不是数组
  * toString():返回数组的字符串表示，中间以逗号分隔；与toLocalString()区别，toLocalString()调用的是每一项的toLocalString()方法
  * join():返回以不同分隔符构建的字符串
  * push(),pop(),shift(),unshift():分别为将参数逐个添加到数组末尾并返回数组长度，从数组末尾移除最后一项然后返回移除的项，移除数组的第一个项并返回该项，在数组前端添加任意个项并返回数组长度
  * reserve(),sort():反转数组的顺序；升序排列数组，可接受一个比较函数作为参数进行排序
  * contact():基于当前数组所有项创建一个新数组，将两个数组进行连接，若传入的不是数组则添加到结果数组的末尾
  * splice():不会影响原数组，参数分别为起始位置和结束位置。删除(要删除的第一项位置，要删除的项数)；替换(起始位置，0，要插入的项) ；删除(起始位置，要删除的项数，要插入的项)
  * IndexOf(),lastIndexOf():参数为要查找的项和查找起点位置的索引(可选)。没有找到返回-1
  * 迭代方法
    * every():对数组中的每一项运行给定函数，如果该函数对每一项都返回true则返回true
    * filter():对数组中的每一项运行给定函数，该函数返回true的项形成的数组
    * forEach():对数组的每一项运行给定函数，该函数没有返回值
    * map():对数组的每一项运行给定函数，返回每次函数调用的结果形成的数组
    * some():对数组的每一项运行给定函数,如果该函数对任一项返回true则返回true
  * reduce(),reduceRight():参数(前一个值，当前值，项的索引，数组对象)，函数返回的任何值会作为第一个参数传给下一项

## Date类型

使用new操作符创建一个Date对象

* Date.parse()：接收一个表示日期得到字符串参数，然后根据这个字符串返相应的日期毫秒数
* Date.UTC()：也是返回日期的毫秒数，参数分别是年份，基于0的月份，月中的哪一天，0-23的小时数分钟以及毫秒数
* Date.now()：调用这个方法的日期和事件的毫秒数
* toLocalString()：按照与浏览器设置的地区响应的格式返回日期和时间
* toString()：返回带有时区信息的日期和时间
* 

## RegExp类型

* 匹配模式:g表示全局，将被应用于所有字符串，而非在第一个匹配时终止；i表示不区分大小写；m表示多行
* 元字符必须经过转义`([{\^$|?*+.}])`
* 实例属性:global是否设置了g标志；ignoreCase是否设置了i标志；multiline是否设置了m标志；以上都返回布尔值；source返回正则表达式的字符串表示；lastIndex开始搜索下一个匹配项的字符位置
* 实例方法:exec()接收要应用模式的字符串作为参数，返回包含第一个匹配项信息的数组，不设置为全局时只匹配第一个；test()接收字符串参数，匹配则返回true。配合捕获组使用RegExp.$1.......

## Function类型

* 不推荐使用函数表达式进行声明，需要解析两次代码，降低性能。解析器会率先读取函数声明，并在其执行任何代码之前可访问，函数表达式只解析器执行到所在的代码行才会被解释执行

* 函数可以作为值传递给另一个函数，但是要访问函数的指针而不执行函数，需要去掉括号
* arguments主要用途是保存函数的参数，callee属性指向拥有这个arguments对象的参数，caller保存着调用当前函数的引用

```javascript
function factorial(num){
    if(num <= 1){
        return 1;
    }else{
        return num * factorial(num - 1)
    }
}
//相比之下降低了耦合性
function factorial(num){
    if(num <= 1){
        return 1;
    }else{
        return num * arguments.callee(num - 1)
    }
}
```



## 基本包装类型

* 与引用类型的区别：主要在于对象的生存周期，使用new操作符创建的引用类型的实例，在执行流离开作用域之前都一直保存在内存中。自动创建的基本包装类型，只存在于一行代码执行的瞬间然后立即销毁，所以不能在运行时为基本包装类型添加属性和方法
* 每读取一个基本包装类型值，后台就会创建一个对应的基本包装类型的对象

## Number类型

* valueOf()返回对象表示的基本类型的数值。
* toString(),toLocalString()：返回字符串形式的数值，可传递一个数字作为参数，返回该进制下的字符串
* toFixed()：按照指定的小数返回沪指的字符串表示，会四舍五入
* toExponential()：返回以指数表示法表示该数值的字符串形式，可传入一个参数指定小数位数
* toPrecision()：按指定的参数返回固定位数的数值字符串格式，可为指数形式

## String类型

* 每一个实例属性都有length方法
* 字符方法
  * charAt(),charCodeAt()：以单字符串的形式返回给定位置的那个字符串，charCodeAt()返回的是编码
  * 可以通过方括号中指定下标访问字符串中的字符
* 字符串操作方法
  * contact()：将一个或多个字符串拼接起来，返回拼接得到的新字符串。接受任意多个参数进行拼接。使用+j进行拼接更为简便易行
  * slice(),substr,substring()：都会返回被操作字符串的一个子字符串，都接受一个或两个参数。第一个参数指定子字符串开始的位置，第二个参数表示子字符串到哪里结束。如果没有传递第二个参数，则以字符串长度作为结束位置。不会修改字符串本身的值
    * slice()和substring()第二个参数指定的是字符串的最后一个字符后面的位置，substr()第二个参数指定的是返回的字符串个数。
* 字符串位置方法
  * IndexOf()和lastIndexOf()：搜索给定的子字符串然后返回子字符串的位置没有找到则返回-1，可以接受第二个参数，表示从哪个位置开始搜索。在指定第二个参数情况下，可以循环调用来找到所有匹配的字符串。
* trim()：清除前置和后缀的空格
* toLowerCase(),toUppercase(),toLocalLowerCase(),toLocalUpperCase()：大小写转换，后两者针对特殊地区
* 模式匹配方法：
  * match()：接收一个参数，正则或RegExp对象与exec()方法相同
  * search()：参数与match()相同要求，返回字符串中第一个匹配的索引
  * replace()：接收两个参数，正则或RegExp与一个字符串或函数，替换所有需指定全局匹配
* split()：基于指定分隔符将字符串分割成多个子字符串，并将结果放在一个数组中，可接受第二个参数指定数组的大小
* localCompare()：比较两个字符串。字符串排在参数字符串之前返回-1；相同返回0；之后返回1.
* fromCharCode()：接收一或多个字符编码，将他们转换为字符串

## 对象Object类型

* 对象的数据属性：包含一个数据值的位置。在这个位置可以读取和写入值。
  * Configurable：表示能否通过delete删除属性从而重新定义新属性，能否修改属性的特性，或者能否把属性修改为访问器属性。
  * Enumerable：表示能否for-in循环返回属性。
  * Writable：表示能否修改属性的值。
  * Value：包含这个属性的数据值

* Object.defineProperty()
  * 修改属性默认的特性，该方法接收三个参数，分别是属性所在的对象，属性的名字和一个描述符对象。描述符对象的属性必须是configurable,enumerable,writable和value。设置其中的一个或多个值，可以修改对应的特性值
  * 把configurable属性设为false，表示不能从对象中删除属性。如果对这个属性调用delete，在严格模式下回导致错误。一旦把属性定义为不可配置的，就不能把它再变回可配置了。此时再调用该方法修改writable之外的特性都会导致错误

```javascript
var person = {};
Object.defineProperty(person,"name",{
	writable:false,
	value:"Nicholas"
})
alter(person.name)  //Nicholas
person.name = "Grey"
alter(person.name)  //Nicholas
```

* 对象的访问器属性：不包含数据值，包含一个getter和setter函数(不是必须的)，在读取访问属性时，会调用getter函数，这个函数负责返回有效的值。在写入属性时调用setter函数并传入新值，这个函数负责决定如何处理数据。以下是他的特性
  * Configurable：表示能否通过delete删除属性从而重新定义新属性，能否修改属性的特性，或者能否把属性修改为访问器属性。
  * 表示能否for-in循环返回属性。
  * Get：在读取属性时调用，默认值为undefined
  * Set：在写入属性时调用，默认值为undefined
* 访问器属性不能直接定义，必须使用Object.defineProperty()的方法来定义。

```javascript
var book = {
	_year:2004,
	edition:1
}
Object.defineProperty(book,"year",{
	get:function(){
		return this._year;
	},
	set:function(newValue){
		if(newValue > 2004){
			this._year = newValue;
			this.edition += newValue -2004
		}
	}
})
book.year = 2005;
alert(book.edition)    //2
//_year前面的下划线是一种常用的记号，用于表示只通过对象方法访问的属性
```

* 定义多个属性：Object.defineProperties()
  * 利用这个方法可以通过描述符一次定义多个属性。接收两个参数分别是：添加和修改其属性的对象，第二个对象的属性与第一个对象中要添加或修改的属性一一对应

```javascript
var book = {};
Object.defineProperties(book,{
	_year:{
		value:2004
	},
	edition:{
		value:1
	},
	year:{
		get:function(){
		return this._year;
		},
		set:function(newValue){
			if(newValue > 2004){
				this._year = newValue;
				this.edition += newValue -2004
			}
		}
	}
})
```

* 读取属性的特性：Object.getOwnPropertyDescriptor()，可以取得给定属性的描述符
  * 接收两个参数：属性所在的对象和要读取其描述符的属性名称。返回值是一个对象

```js
//以上述对象为例
var descriptor = Object.getOwnPropertyDescriptor(book,"_year");
alert(descriptor.value)  //2004
alert(descriptor.configureable)  //false
alert(typeof descriptor.get)  //undefined

var descriptor = Object.getOwnPropertyDescriptor(book,"_year")
alert(descriptor.value)  //undefined
alert(descriptor.enumerable)  //false
alert(typeof descriptor.get)  //"function"
```

* 关于对象的复制

## JavaScript难点

### 数据类型

基本类型(值类型)：String，Number，boolean，undefined，null，Symbol

引用类型(对象类型)：Object，Function，Array。后两者都是特殊的对象

判断方式：

* typeof：返回数据类型的字符串表达，类型判断时使用小写。可以判断undefined/数值/字符串/布尔值/function。不能判断null/object/array
* instanceof：判断对象的具体类型
* ===：可以判断undefined和null

### 内存的分类

栈：全局变量和局部变量

堆：存放对象

### 关于作用域

关于作用域首先要说变量的赋值，变量的赋值会执行两个动作，首先会在当前作用域内声明一个变量，然后在运行时引擎就会在作用域内查找该变量，如果找到就会对他赋值。总的来说作用域是一套规则，用于确定在何处以及如何查找标识符。

* 关于作用域的嵌套，当一个块或一个函数嵌套在另一个块或者另一个函数中时，就会发生作用域的嵌套。这样的话如果在当前作用域中没办法找到某个变量时，引擎就会在他外层的作用域内查找，直到找到这个变量，或者是到全局作用域为止
* 词法作用域
  * 作用域的查找流程，先从最内部的作用域开始查找，引擎无法找到需要的变量就会去上一层嵌套的作用域中查找，作用域查找会在找到第一个匹配的标识符时停止，在多层的作用域中可以定义同名的标识符，内部的标识符即遮蔽了外部的标识符。  换种说法就是，当代码在环境中执行时，会创建变量对象的一个作用域链，保证对有权访问的所有变量和函数进行有序访问。内部环境可以通过作用域链访问所有的外部环境，外部环境不能访问内部环境的任何变量与函数。
  * 全局变量会自动成为全局对象，所以可以通过全局对象属性的引用来进行访问，这样可以访问被同名变量遮蔽的全局变量。

* 函数作用域
  * 每声明一个函数都会为其创建一个函数的作用域，属于这个函数的所有变量都可以在整个函数的范围内使用和复用
  * 这段代码中的任何声明的变量或函数都被绑定在这个作用域内而不是之前的作用域，通过函数作用域也可以将一些变量进行隐藏，让外部的作用域无法进行访问。
  * 问题：需要声明一个具名函数，函数的名称就污染了全局作用域，然后必须通过显示调用才能运行其中的代码
    * 解决：(function foo(){...})();这也就是立即执行函数，意味着foo只能在他自己所代表的位置被访问，外部作用域则不行，其他的函数名被隐藏在自身中不会污染全局变量
  * 函数声明和函数表达式之间最重要的区别也就是把他们的名称标识符会被绑定在声明地方
* 块作用域
  * ES5中只有全局作用域和函数作用域，可能会导致内层变量覆盖外层变量，用来计数的循环变量泄露为全局变量
  * ES6新增了块级作用域，比如let,const等定义的块级作用域

### 关于几个函数

* 匿名函数
  * 比如说setTimeout中调用的方法，他的function没有名称标识符。函数表达式可以匿名但函数声明不可以省略函数名，
  * 匿名函数的缺点
    * 在追踪调试时不会显示出具体函数名
    * 没有函数名，函数调用自身时只能通过arguments.callee引用
    * 降低了代码的可读性
* 立即执行函数
  * 将函数包含在一对括号中，通过在末尾添加()可以立即执行函数
  * 可以形成匿名函数表达式，也可以将他作为一个参数传递
  * 可以倒置代码的执行顺序，将要运行的函数放在第二位，在立即执行函数执行之后当做参数传入

### 关于变量提升

var a = 2。JavaScript会将其看成两个声明，分别是var a和a=2.第一个声明是在编译阶段进行的。第二个声明会等待执行阶段。也就是说只有声明本身会被提升，赋值操作会留在原地。函数声明也会被提升，但函数表达式不会被提升。

* 函数会首先被提升，然后才是变量。所以要注意覆盖问题。
* 一个普通块内部的函数声明通常会被提升到所在的作用域顶部

### 关于闭包

能够读取其他函数内部变量的函数，或者子函数在外面调用，子函数所在的父函数作用域不会被释放。也就是在外部函数执行后，一般他的整个内部作用域都会被垃圾回收机制销毁释放不再使用的内存空间，而闭包可以使它不被销毁，因为他本身仍旧在使用

指有权访问另一个函数作用域中的变量的函数。闭包就是函数的局部变量集合，只是这些局部变量在函数返回后会继续存在。就是函数的堆栈在函数返回后并不释放，可以理解为这些函数堆栈不在栈上分配而是在堆上分配。当在一个函数内定义另一个函数就会产生闭包

* 闭包满足两个条件：即使上下文销毁依然存在；在代码中引入了自由变量
* 也就是说当函数可以记住并访问所在的词法作用域，即使函数是在当前词法作用域之外执行，就产生了闭包。
* 应用，比如for循环用定时器输出i，延迟函数的回调会在循环结束才执行。使用闭包可以让他访问外部变量且正确执行；还可以实现模块模式，为创建内部作用域而调用一个包装函数包装函数的返回值至少包括一个对外部函数的引用，这样就会创建涵盖整个包装函数内部的作用域的闭包
* 匿名自执行函数：变量如果不加上var关键字就默认会添加到全局对象的属性上去。这样临时变量加入全局会有很多坏处，比如别的函数可能误用这些变量造成全局对象过于庞大，影响访问速度(因为变量的取值是需要从原型链上遍历的)。除了每次都要使用的变量外，有些函数只需要执行一次，其内部变量无需维护，可以使用闭包
* 结果缓存：若有一个函数处理调用起来很耗时间，就需要将计算出来的值储存起来，当调用这个函数时先在缓存中查找，如果找不到则进行计算更新缓存，如果找到了就直接返回查找到的值。闭包可以做到这点因为它不会释放外部的引用从而使函数内部的值得以保留

### 关于this

this可以隐式传递一个对象的引用，引用的是函数据以执行的环境对象。

this是在运行时绑定的，并不是在编写时绑定，它的上下文取决于函数调用时的各种条件。this的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。当一个函数被调用时，会创建一个活动记录(也就是执行上下文)。这个记录包含函数在哪里被调用，函数调用的方法，传入的参数信息等。this就是记录的其中一个属性，会在函数执行的过程中调用

* 调用位置：是函数在代码中被调用的位置(而不是声明的位置)

```js
//关于调用栈和调用位置
function baz(){
	//当前调用栈是baz,因此当前调用的位置是全局位置
	console.log("baz");
	bar()  //bar的调用位置
}
function bar(){
	//当前的调用栈是baz-bar,因此当前的调用位置是在baz中
	console.log("bar");
	foo()  //foo的调用位置
}
function foo(){
	//当前的调用栈baz-bar-foo,当前调用位置在bar中
	console.log(foo);
}
baz();  //baz调用的位置
```

* this的绑定规则：
  * 默认绑定：独立函数调用，可以把这条规则看作是无法应用其他规则时的默认规则。默认绑定this指向全局对象。
  * 隐式绑定：考虑调用位置是否有上下文对象，或者说是否被某个对象拥有或者包含
  * 显示绑定：不在对象内部包含引用，而是在某个对象上强制调用函数.可以通过函数的call和apply方法
  * new绑定：函数或方法调用之前带有new关键字，构成构造函数的调用。
    * 没有return，计算结果是这个新对象的值
    * 有return没有指定返回值，忽略返回值，使用该新对象作为调用结果
    * 有返回值，调用表达式的值就是这个对象

```js
//默认绑定
function foo(){
	console.log(this.a);
}
var a = 2;
foo();  //2
//隐式绑定
function foo(){
	console.log(this.a);
}
var obj = {
	a:2;
	foo:foo
};
obj.foo()
//显式绑定
function foo(){
	console.log(this.a);
}
var obj = {
	a:2
}
var bar = function(){
	foo.call(obj)
}
bar()  //2
//new绑定
function foo(a){
	this.a = a;
}
var bar = new foo(2);
console.log(bar.a);
```

默认绑定时不能使用严格模式，如果使用严格模式那么全局对象将无法进行默认绑定，this会绑定到undefined

隐式绑定中的隐式丢失：也就是隐式绑定的函数会丢失绑定对象，应用默认绑定，从而把this绑定到全局对象或者undefined上

显式绑定中第三方库的许多函数以及js的许多内置函数，都提供了一个可选参数确保函数使用指定的this

* 优先级问题：按照下面的顺序进行判断
* .0
  * 函数是否在new中调用，如果是的话this绑定的是新创建的对象
  * 函数是否通过call，apply显示绑定或硬绑定调用。如果是的话this指向的就是绑定的对象
  * 函数是否在某个上下文对象中调用(隐式绑定)。如果是的话this绑定的就是上下文对象
  * 如果都不是的话使用默认绑定，严格模式下绑定undefined，否则绑定到全局对象
* this中的绑定例外

### Prototype

是对于其他对象的引用，几乎所有对象在创建时prototype属性都会被赋予一个非空的值。

##### 作用1

关于他的用处：当试图引用对象的属性时会触发get操作，对于get操作来说，第一步就是检查对象本身是否拥有这个属性，有的话就使用它。但是如果这个属性不再该的对象中，就需要使用对象的prototype链。比如无法获取这个对象中的a属性，就会继续访问该对象的prototype链。这个查找的过程会持续到匹配到属性名或查找完整条prototype链。使用for...in遍历对象或in操作符检查属性在对象中是否存在时，都会查找对象的整条原型链

* 此处提一下Object.create()方法，会穿件一个对象并把这个对象的prototype关联到指定对象。

* 所有prototype原型链的尽头都会执行内置的Object.prototype

当为对象的属性设置值时，如果对象中包含对应属性则会修改已有的属性值，该属性值会屏蔽其prototype链上的属性值；如果该属性不是存在于该对象中，那么就会去prototype链上遍历，存在以下三种情况：在后两种情况下若想覆盖只能使用Object.defineProperty()

* 如果prototype链上存在该属性并且没有标记为只读，那就会在要设置的对象中添加一个该属性，屏蔽之前属性
* 如果存在且被标记为只读，那么久无法在要设置的对象中设置该属性值，严格模式下还会报错
* 如果存在该属性并且它是一个setter，那就会调用这个setter而不是重新设定

##### 作用2

模仿类：利用了函数的特性：所有函数都会默认拥有一个名为prototype的公有的并且不可枚举的属性，它会指向一个对象，他指向的对象通常被称为原型，通过方法名.prototype的属性引用来访问它。这个对象是在调用new Foo()时创建的，最后会被关联到Foo.prototype指向的那个对象。在js中不能创建一个类的多个实例，只能创建一个对象使他们的prototype关联上同一个对象。new Foo会生成一个新对象，比如a，这个新对象的prototype关联的是Foo的prototype。这个机制通常被称为原型继承。继承意味着赋值操作，但Js默认情况下并不会赋值对象属性，而会在两个对象之间创建一个关联，这样可以通过委托访问另一个对象的属性和函数



```
是实现继承的主要方法，基本思想史利用原型让一个引用类型继承另一个引用类型的属性和方法。
每个构造函数都有一个原型对象，原型对象包含一个指向构造函数的指针。而实例都包含一个指向原型对象的内部指针。
当创建一个函数，就会为该函数创建一个prototype属性，这个属性指向函数的原型对象，默认情况下所有原型对象都会获得一个constructor(构造函数)属性，这个属性是一个指向prototype属性所在函数的指针
prototype的作用是在多个实例对象之间共享数据和方法；通过原型链实现继承
原型链：
每个构造函数都要一个原型对象，原型对象都包含一个指向构造函数的指针，构造函数的实例对象都有一个指向原型对象内部的指针
如果让原型对象等于另一个构造函数的实例对象，此时原型对象内部也包含另一个指向另一个构造函数的原型对象的指针
```

---

在ES6之前没有类和继承的概念，js是通过原型来实现继承的。在js中药柜构造函数默认带有一个prototype属性，这个属性值是一个对象，同时这个prototype对象自带有一个constructor属性，这个属性指向这个构造函数，同时每一个实例都会有一个\__proto__属性指向这个prototype对象，可以把这个叫做隐式原型，我们在使用一个实例方法的时候，会先检查这个实例中是否有这个方法，没有的话会检查prototype对象是否有这个方法。



#### 间歇调用和超时调用

* 用来调度代码在特定的时刻执行，间歇调用为每隔指定时间就执行一次代码，超时调用为指定时间过后执行代码。
* 第一个参数可为JavaScript字符串或一个函数，但传递字符串可能会造成性能损失。
* 可通过clearTimeout()与clearInterval()取消超时和间接调用

#### BOM中的常用对象

window对象是BOM的核心对象，可听过他调整窗口位置大小以及打开新窗口。，location对象用来改变浏览位置，也就是当前的页面；navigator对象识别客户端浏览器，screen屏幕，history历史

#### json

* json其中数据类型可为简单值，对象和数组；要求给属性加引号

