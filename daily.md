# 总结问题

### SEO优化

主要影响是搜索引擎爬虫对页面的抓取，影响搜索结果中的排序

title，description，keywords

语义化html代码，将重要的html代码放在前面，因为搜索引擎的抓取顺序是从上到下抓取

爬虫不会抓取js的内容，所以重要的内容不能用js输出

非装饰性图片使用alt，同时还可以增强无障碍性

提高网站的速度----此处涉及前端性能优化



### 前端性能优化--具体见性能优化

* 减少http请求
  * 图片地图，css精灵图，内联图片，内联脚本，合并文件
  * 添加Expires头
* 减少DNS查询
  * 将资源分布到恰当数量的主机名
* 服务器方面
  * 使用CDN内容发布式网络
  * 对组件使用gzip压缩
* js与css
  * 使用外部的JavaScript和css
  * 避免css表达式
  * 将脚本放在底部
  * 将样式表放在顶部
  * 使用link，不使用@import
  * 精简压缩js
  * 合并脚本和样式表
* 按需导入



### 输入url到渲染的流程--具体见http-输入url到页面渲染的过程

* 输入url客户端发送域名给DNS服务器解析为ip地址，然后将ip地址返回给浏览器
* 客户端根据ip地址连接到web服务器
* 三次握手建立TCP连接后发送http请求
* 服务器接收到http请求后返回响应报文
* 四次握手释放ThtmlCP连接
* 客户端开始解析HTML内容
* 浏览器渲染页面
  * 深度遍历把html节点遍历成DOM树
  * 将css解析成css DOM树
  * 将dom树和css DOM树构造成render树
  * js根据得到的render树计算所有节点在屏幕中的位置进行布局（回流）
  * 遍历render树并调用硬件API绘制所有节点



### 语义化的理解

* 有利于SEO优化
* 语义化的标签便于对页面的内容进行分块,使内容结构化便于浏览器解析
* 方便阅读和维护



### html5新特性---html

* 用于视屏和音频播放的audio和video
* 表单元素的扩展--新增calendar，date，time，email，url
* 语义化标签--article，section，footer，header，nav
* localStorage，sessionStorage



---



### cookie，session，sessionStorage，localStorage---http

* 储存位置

* 有效期
* 作用域
* 应用场景





### 前端攻击方式---http

#### CSRF/XSRF攻击

跨站请求伪造：用户浏览并登陆可信任的网站后，网站会给他产生一个cookie。用户在没有退出该网站的时候访问另一个危险网站。危险网站发出访问安全网站的请求导致通过用户去cookie访问了安全网站，安全的网站无法分辨请求是谁发出的所以危险网站可以操作安全网站中的用户的操作。

这也就是说，他的流程是登录可信任网站，生成cookie在不登出安全网站的情况下访问危险网站。

**防御方法：**总体的思想是在客户端页面增加伪随机数

* **Cookie.Hashing：**理论上攻击者不能获取第三方的cookie，所以在表单中加入Hash值以确认这是用户发送的请求，然后在服务端进行hash值验证
* **验证码：**每次用户提交都需要在用户表单上填写一个图片上的随机字符串
* **One-Time Tokens：**不同的表单包含 一个不同的伪随机值，需要注意的是并行会话的兼容，如果用户在一个站上同时打开了两个不同的表单，CSRF保护措施不应该影响到他对任何表单的提交，就是用户只能提交他最后的表单，因为其他的表单都含义非法的伪随机值，

#### XSS攻击及预防措施

关于cookie如何防范xss攻击：xss(跨站脚本攻击)，值攻击者在返回的html中嵌入JavaScript脚本，为了减轻这些攻击，需要在HTTP头部配上set-cookie：

* httponly：这个属性禁止JavaScript脚本来访问cookie
* secure：这个属性会告诉浏览器仅在请求https时发送cookie

#### SQL注入攻击

就是通过网站输入的内容构造数据库时，攻击者可以通过把sql命令插入到表单提交中从而连接数据库拿到权限等等

**防御方法：**一般是通过正则来防止用户输入有关sql的特殊字符和关键字



### http各个版本的新特性---详见http

1.0

新增状态码

支持二进制数据

TCP建立一次连接后只能发送一次数据

1.1

持久连接

管道机制，并发传输

编码分块传输

端点传输

2.0

完全二进制

多路复用

头信息压缩

服务器推送



---



### 重绘与重排---css

这个问题先要说浏览器的运行机制

* 构建DOM树
* 构建渲染树
* 布局渲染树
* 绘制渲染树

重绘：当盒子模型的位置，大小以及其他比如字体大小之类的都确定之后，浏览器将这些元素绘制将内容呈现在页面上。重绘是指一个元素的外观发生改变的时候触发浏览器的行为，浏览器会根据元素的新属性重新绘制使元素呈现新的外观

重排：当渲染树中的一部分或元素因为元素的规模尺寸，布局隐藏等改变而需要重新构建，这就是重排。每个页面至少需要一次重排就是页面第一次加载的时候

重排必定引发重绘，重绘不一定引发重排

重排的条件：页面初始渲染；添加或删除可见的DOM元素；元素改变位置或使用一些动画效果；元素尺寸改变；浏览器窗口尺寸改变，需触发resize事件；填充内容的改变





### 垃圾收集机制---JavaScript

原理：找出不再继续使用的变量然后释放其占用的内存

引用计数：每当声明一个变量并将一个引用类型的值赋值给这个变量时，这个变量的引用次数就是1.如果同一个值又被赋值给另一个变量，则引用次数加一；如果这个值引用的变量取得了另一个值，则这个值的引用次数减一；当它为0 时垃圾回收机制自动释放

标记清除：当生命变量时，会将变量标记为进入环境，当变量离开环境时，会将变量标记为离开环境。垃圾收集器会去掉环境中的变量以及环境中的变量引用的标记变量；在此之后再被加上标记的变量被视为准备删除的变量；

标记阶段：垃圾回收机制会从根开始遍历，可以访问到的变量都会被添加一个标识为可达到对象

清除阶段：对堆内存从头到尾进行线性遍历，如果变量没有被标记为可达到的对象，就会将原先标记清除以便下一次回收操作



### 作用域---JavaScript

是一套规则，用于确定在何处以及如何查找标识符

查找流程：从最内部的作用域开始查找，会创建变量对象的一个作用域链，保证对有权访问的所有变量和函数进行有序访问。内部环境可以通过作用域链访问外部环境，外部环境不能访问内部环境，这就造成了内部标识符遮蔽了 =内部标识符

词法作用域：全局变量会自动提升为全局对象，可以通过全局对象的属性来访问，这样可以访问到被同名表示符遮蔽的外部作用域

函数作用域：每声明一个函数都会为其创建一个函数的作用域，属于这个函数的所有变量都可以在整个函数的范围内使用和复用；通过函数作用域也可以对一些变量进行隐藏，但这样会引发一个问题就是生命的函数名会提升为全局变量污染全局作用域，；函数声明和函数表达式的区别也在于他们的名称标识符会绑定在声明的地方

块级作用域：ES6新增，可随意嵌套





### 闭包---JavaScript

JavaScript中函数内部可以读取外部的变量，但在函数外部无法读取函数内部的变量（函数内部声明变量时一定要使用声明符号比如let和var不然会变成全局变量）；为了在函数外部可以读取函数内部的变量就可以使用闭包在函数内部再定义一个函数，使用这个函数来访问变量操作，然后将这个函数返回；

作用：读取函数内部变量；让这些变量的值始终保存在内存中

始终保存在内存中是因为子函数在外调用，子函数所在的复函数作用域不会被释放，在外部函数执行后，一般他的整个内部作用域都会被垃圾回收机制销毁释放不再使用的内存空间，而闭包可以使他不销毁，因为他本身仍然在使用

闭包满足的两个条件：上下文销毁依然存在，代码中引入了自由变量

应用：匿名自执行函数；结果缓存；模仿块级作用域；单例模式



### this---JavaScript

可以隐式传递一个对象的引用，引用的是函数据以执行的环境对象；this是在运行时绑定的而不是在编写时绑定的，他的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式，当一个函数被调用时，会创建一个活动记录（执行上下文）：这个记录会包含函数在哪里被调用，函数的调用方法，传入的参数信息；this就是记录的其中一个属性，会在函数执行过程中调用

绑定规则（优先级从低到高）

* 默认绑定：默认绑定this指向全局对象
* 隐式绑定：考虑调用位置是否有上下文对象，也就是说是否被某个对象拥有或包含
* 显示绑定：使用call和apply进行强制绑定
* new绑定：函数或方法调用之前带有new关键字造成构造函数的调用



### 跨域---http

同源策略：

* 两个页面的协议，端口，域名相同则两个页面具有相同的源；即使两个不同的域名指向同一个ip地址也不是同源
* 它限制了从同一个源加载的文档如何与来自于另一个源的资源进行交互，是用于隔离潜在恶意文件的重要安全机制；
* 限制的行为
  * cookie，localStorage，indexDB，DOM对象，js对象无法获得，ajax请求无法发送
* 常见场景
  * 同一域名，不同文件或路径
  * 同一域名不同端口
  * 同一域名不同协议
  * 域名和域名对应相同ip
  * 主域相同子域不同
  * 不同域名



跨域：一个域下的脚本试图去请求另一个域下的脚本

* 资源跳转：a标签，重定向，表单提交
* 资源嵌入：link，script，img，frame等dom操作，样式中的文件外链
* js发起的ajax请求，dom和js对象的跨域操作

**解决方案：**

* jsonp：为了减轻服务器的负载，把js，css，img等静态资源分离到另一台独立域名的服务器上，在html中通过对应标签从不同域名下加载静态资源从而被浏览器允许，动态创建script，请求一个带参网址实现跨域通信
* document.domain+iframe：两个页面都通过document.domain设置基础主域；只适用于主域相同，子域不同的跨域应用场景
* location.hash+iframe：通过第三个页面来实现，不同域之间利用iframe的location.hash传值，相同域直接js访问通信
* window.name+iframe：name值在不同域名和不同页面中加载后依然存在
* 在ajax中设置：xhr.withCredentials = true
* Nginx，Nodejs，Webpack中设置





### http控制缓存参数---http

* Pragma：该字段值为no-cache时会通知客户端不要对该资源读取缓存
* Expires：值对应一个时间来告诉浏览器资源缓存过期时间；如果与pragma同时存在则pragma先起作用
* Cache-Control：Expires的时间是相对于服务器而言，无法保证和客户端同一的问题；能够在请求报文和响应报文中使用；若与Expires同时出现则使用Cache-Control；
* Last-Modified：服务器将资源传给客户端时，会将资源最后更改的事件以Last-Modified的形式加在实体首部上一起返回给客户端；客户端会为资源标记上该信息，下次请求时会把该信息附带在请求报文中发送给服务器做检查，如果传递的时间值与服务器最后修改的时间值一致则说明没有做过修改，则直接返回304状态码，内容为空；时间不一致则返回200，然后返回资源；
* ETag：解决时间不准确的问题，通过某种算法给资源计算得出唯一标识符，然后会一起返回给客户端用于比较，和Last-Modified类似



### 宏任务，微任务---JavaScript

js在处异步操作时使用的是事件循环机制：处理顺序：同步任务---异步任务（微任务---宏任务）

每次准备取出一个宏任务执行前，都要将所有的微任务一个一个取出来执行

微任务操作：Promise；MutationObserver

宏任务：setTimeOut；setInterval；I/O操作；dom事件回调；ajax回调



### TCP三次握手四次挥手

* 三次握手：建立TCP连接，一方主动打开，一方被动打开；为了防止服务端开启一些无用的连接增加服务器开销

  * 首先客户端向服务端发送一段TCP报文，请求建立连接
  * 服务端接收到来自客户端的TCP报文后，返回一段TCP报文，表示客户端的报文有效服务端能够正常接收客户端发送的数据并同意创建新连接
  * 客户端接收到来自服务器确认收到数据的TCP报文后明确了从客户端到服务器的传输时正确的，并返回最后一段TCP报文，表示确认收到服务器端同意连接的信号

* 四次挥手：TCP连接的释放，一方主动释放一方被动释放

  * 客户端想要释放连接，向服务端发送一段TCP报文，表示请求释放连接
  * 服务端接收到客户端发出的TCP报文之后确认了客户端想要释放连接，并返回一段TCP报文表示接收到客户端发送的请求释放连接的请求
  * 服务端做好彻底释放连接的准备后，再次发出一段TCP报文表示准备好释放连接
  * 客户端收到报文后确认服务器做好释放报文的准备，想服务器发送一段报文表示接收到服务器准备好释放连接的信号

  之后服务器先开始关闭连接，客户端等待一段时间确认服务器收到确认报文后关闭，因为客户端不能确定服务器释放收到，这段时间内如果服务器没有收到客户端的确认报文会再次发送一段报文









### 事件冒泡与默认事件及阻止---JavaScript

* 事件冒泡
* 事件捕获
* 事件监听的方法
* 事件模型的常用方法
* 使事件先冒泡后捕获
* 事件委拖



### 元素消失的方式

* display:none
* visibility:hidden
* opacity:0





### 浮动与浮动清除

浮动的特性：

* 浮动元素脱离标准流
  * 就是不在页面中占位置
  * 所有标签一旦设置浮动就能够并排，并且都不区分行内，块状元素，并且能够设置宽高
* 浮动的元素相互贴靠
  * 只要有足够位置就会相互贴靠
* 浮动的元素有字体围绕效果
* 浮动元素紧凑效果
  * 一个浮动元素如果没有设置width就自动收缩为文字的宽度



清除浮动：因为浮动会影响页面中其他元素的布局所以需要清除浮动

* 给父盒子设置高度

  * 浮动元素都在父盒子内操作就不会影响到父元素宽高外的其他元素

* clear:both：给浮动元素最后面加一个空的div并且该元素不浮动，然后这只clear:box

  * left：当前元素左边不允许有浮动元素
  * right：当前元素右边不允许有浮动元素
  * both：当前元素两边不允许有浮动元素

* 伪元素清除法

  * 给浮动元素的父盒子也就是不浮动元素添加一个clearfix类

  * ```css
    .clear:after {
        content: '';
        clear: both;
        display: block;
    }
    ```

* overflow:hidden

  * 浮动元素脱离标准流后父级元素检测不到子元素的高度所以为0；所以需要给父级元素加个overflow:hidden属性，这样父级元素随子集容器内容自适应；为了提升兼容性加一个zoom:1；当设置了zoom的值后，所设置的元素就会扩大或缩小，高度就会重新计算，运用这个原理解决了IE元素浮动时父元素不随其自动扩大的问题





### BFC

是块级盒布局出现的区域，也是浮层元素进行交互的区域

形成条件：

* float的值不是none
* position的值不是static或者relative
* display的值是inline-block，table-cell，flex，table-caption，inline-flex
* overflow的值不是visible

功能：

* 避免margin重叠：属于同一个BFC的两个相邻box会产生margin重叠
* 实现两栏式自适应布局：BFC区域不会和浮动box重叠，所以将另一个元素设置为BFC时它就能自适应
* 清除浮动：如果不给父节点设置高度子元素设置浮动时就会产生高度塌陷，且计算BFC高度时浮动元素也参与计算

* 使BFC内浮动元素不会乱跑；
* 和浮动元素产生边据，因为如果没有BFC想要产生这个边距，就得将margin设置为边距加上另一个元素的宽度



### 请求报文，响应报文

请求报文格式

响应报文格式

方法

状态码

首部



### 水平居中，垂直居中，水平垂直居中

**水平居中**

* margin:0 auto

  * 有宽度时适用

* ```css
  子：display:inlineblock
  父：text-align:center
  ```

  * 有无宽高都适用

* Position定位：子绝父相，子元素left值为50%，margin-left为负值自身宽度的一半

  * 有宽高适用

* transform：子绝父相，子元素left值为50%，transform:translate(-50%,0%)

  * 有无宽高都适用

* flex布局：justify-content:center

  * 有无宽高都适用

* 元素为行内元素，设置父元素text-align:center
* 元素宽度固定设置左右margin为auto
* 子绝父相，left:0,right:0,margin:auto
* display:table-cell

**垂直居中**

* position定位：子绝父相，子元素left值为50%，margin-left为负值自身宽度的一半
  * 有宽高适用

* transform：子绝父相，子元素left值为50%，transform:translate(0%,-50%)
  * 有无宽高都适用

* flex布局：align-items:center
  * 有无宽高都适用

* display:table-cell,vertial-align:middle
* bottom:0,top:0,margin:auto
* 文本垂直居中时设置line-height为height值

**水平垂直居中**

* position定位

* transform

* flex布局

* 父元素display:table-cell；子元素vertical-align:middle；text-align:center；

* JavaScript实现

  ```js
  let Html = document.documentElement;
  let winW = Html.clientWidth;
  let winH = Html.clientHeight;
  let boxW = box.offsetWidth;
  let boxH = box.offsetHeight;
  
  
  box.style.position = "absolute"
  box.style.left = (winW-boxW)/2+'px'
  box.style.top = (winH-boxH)/2+'px'
  
  
  
  ```

  



### this指向

一般函数this指向全局作用域window

严格模式下适用use strict，为undefined

对象的方法里调用指向调用该方法的对象

构造函数里的this指向创建出来的实例











# 面试问题



### DOM树和Render树

DOM树是包含了所有html节点的树，渲染树是DOM树和CSSOM树组合而成的，最终渲染在页面上的树。DOM树和渲染树都是浏览器生成的



### 为什么基本类型可以有属性和方法

后台会创建对应的包装类型的实例，然后调用实例指定的方法，调用完就会被销毁





### DOMContentLoad，Load

当纯HTML被完全加载以及解析时，DOMContentLoaded事件会被触发，而不必等待样式表，图片或者子框架完成加载

当一个资源及其依赖资源已完成加载时，会触发load事件



### 有符号位移，无符号位移

左移运算符<<：按二进制形式把所有的数字向左移动对应的位数，高位移出(舍弃)，低位的空位补0。

右移运算符>>：按二进制形式把所有的数字向右移动对应位移位数，低位移出(舍弃)，高位的空位补符号位，即正数补0，负数补1。

无符号右移运算符：按二进制形式把所有的数字向右移动对应位数，低位移出(舍弃)，高位的空位补零。对于正数来说和带符号右移（>>） 相同，但是对于负数来说不同。

### parseInt的参数

parseInt(string,radix)

string:要被解析的值，如果参数不是字符串则将其转换为字符串

radix:2-36表示进制







# 单项问题

### SetTimeout参数和返回值

function:delay之后执行的函数

delay:可选：延迟的时间，默认取0

arg1,arg2,arg3...：附加参数，定时器到期后会作为参数传递给function



返回值是一个正整数，表示定时器的编号，可以传递给clearTimeout来取消清时期







### 盒模型box-sizing参数

border-box  IE盒模型

content-box  标准盒模型











# 待完成

### 对象的深浅拷贝---各种类型

浅拷贝：比如数组使用slice,contact方法返回一个新数组的特性来实现拷贝，但如果数组中嵌套了对象或者数组，使用contact方法克隆就不完整，只会拷贝对象和数组的引用；浅拷贝使，在新旧数组中修改数据都会引起另一个组数据的改变