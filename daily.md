### SEO优化

主要影响是搜索引擎爬虫对页面的抓取，影响搜索结果中的排序

title，description，keywords

语义化html代码，将重要的html代码放在前面，因为搜索引擎的抓取顺序是从上到下抓取

爬虫不会抓取js的内容，所以重要的内容不能用js输出

非装饰性图片使用alt，同时还可以增强无障碍性

提高网站的速度----此处涉及前端性能优化



### 前端性能优化--具体见性能优化

* 减少http请求
  * 图片地图，css精灵图，内联图片，内联脚本，合并文件
  * 添加Expires头
* 减少DNS查询
  * 将资源分布到恰当数量的主机名
* 服务器方面
  * 使用CDN内容发布式网络
  * 对组件使用gzip压缩
* js与css
  * 使用外部的JavaScript和css
  * 避免css表达式
  * 将脚本放在底部
  * 将样式表放在顶部
  * 使用link，不使用@import
  * 精简压缩js
  * 合并脚本和样式表



### 输入url到渲染的流程--具体见http-输入url到页面渲染的过程

* 输入url客户端发送域名给DNS服务器解析为ip地址，然后将ip地址返回给浏览器
* 客户端根据ip地址连接到web服务器
* 三次握手建立TCP连接后发送http请求
* 服务器接收到http请求后返回响应报文
* 四次握手释放ThtmlCP连接
* 客户端开始解析HTML内容
* 浏览器渲染页面
  * 深度遍历把html节点遍历成DOM树
  * 将css解析成css DOM树
  * 将dom树和css DOM树构造成render树
  * js根据得到的render树计算所有节点在屏幕中的位置进行布局（回流）
  * 遍历render树并调用硬件API绘制所有节点



### 语义化的理解

* 有利于SEO优化
* 语义化的标签便于对页面的内容进行分块,使内容结构化便于浏览器解析
* 方便阅读和维护



### html5新特性

* 用于视屏和音频播放的audio和video
* 表单元素的扩展--新增calendar，date，time，email，url
* 语义化标签--article，section，footer，header，nav
* localStorage，sessionStorage



### cookie，session，sessionStorage，localStorage---详见http

* 储存位置

* 有效期
* 作用域
* 应用场景





### 前端攻击方式

#### CSRF/XSRF攻击

跨站请求伪造：用户浏览并登陆可信任的网站后，网站会给他产生一个cookie。用户在没有退出该网站的时候访问另一个危险网站。危险网站发出访问安全网站的请求导致通过用户去cookie访问了安全网站，安全的网站无法分辨请求是谁发出的所以危险网站可以操作安全网站中的用户的操作。

这也就是说，他的流程是登录可信任网站，生成cookie在不登出安全网站的情况下访问危险网站。

**防御方法：**总体的思想是在客户端页面增加伪随机数

* **Cookie.Hashing：**理论上攻击者不能获取第三方的cookie，所以在表单中加入Hash值以确认这是用户发送的请求，然后在服务端进行hash值验证
* **验证码：**每次用户提交都需要在用户表单上填写一个图片上的随机字符串
* **One-Time Tokens：**不同的表单包含 一个不同的伪随机值，需要注意的是并行会话的兼容，如果用户在一个站上同时打开了两个不同的表单，CSRF保护措施不应该影响到他对任何表单的提交，就是用户只能提交他最后的表单，因为其他的表单都含义非法的伪随机值，

#### XSS攻击及预防措施

关于cookie如何防范xss攻击：xss(跨站脚本攻击)，值攻击者在返回的html中嵌入JavaScript脚本，为了减轻这些攻击，需要在HTTP头部配上set-cookie：

* httponly：这个属性禁止JavaScript脚本来访问cookie
* secure：这个属性会告诉浏览器仅在请求https时发送cookie

#### SQL注入攻击

就是通过网站输入的内容构造数据库时，攻击者可以通过把sql命令插入到表单提交中从而连接数据库拿到权限等等

**防御方法：**一般是通过正则来防止用户输入有关sql的特殊字符和关键字



### http各个版本的新特性---详见http

1.0

新增状态码

支持二进制数据

TCP建立一次连接后只能发送一次数据

1.1

持久连接

管道机制，并发传输

编码分块传输

端点传输

2.0

完全二进制

多路复用

头信息压缩

服务器推送





### 重绘与重排---css

这个问题先要说浏览器的运行机制

* 构建DOM树
* 构建渲染树
* 布局渲染树
* 绘制渲染树

重绘：当盒子模型的位置，大小以及其他比如字体大小之类的都确定之后，浏览器将这些元素绘制将内容呈现在页面上。重绘是指一个元素的外观发生改变的时候触发浏览器的行为，浏览器会根据元素的新属性重新绘制使元素呈现新的外观

重排：当渲染树中的一部分或元素因为元素的规模尺寸，布局隐藏等改变而需要重新构建，这就是重排。每个页面至少需要一次重排就是页面第一次加载的时候

重排必定引发重绘，重绘不一定引发重排

重排的条件：页面初始渲染；添加或删除可见的DOM元素；元素改变位置或使用一些动画效果；元素尺寸改变；浏览器窗口尺寸改变，需触发resize事件；填充内容的改变





### 垃圾收集机制

原理：找出不再继续使用的变量然后释放其占用的内存

引用计数：每当声明一个变量并将一个引用类型的值赋值给这个变量时，这个变量的引用次数就是1.如果同一个值又被赋值给另一个变量，则引用次数加一；如果这个值引用的变量取得了另一个值，则这个值的引用次数减一；当它为0 时垃圾回收机制自动释放

标记清除：当生命变量时，会将变量标记为进入环境，当变量离开环境时，会将变量标记为离开环境。垃圾收集器会去掉环境中的变量以及环境中的变量引用的标记变量；在此之后再被加上标记的变量被视为准备删除的变量



### 作用域

是一套规则，用于确定在何处以及如何查找标识符

查找流程：从最内部的作用域开始查找，会创建变量对象的一个作用域链，保证对有权访问的所有变量和函数进行有序访问。内部环境可以通过作用域链访问外部环境，外部环境不能访问内部环境，这就造成了内部标识符遮蔽了 =内部标识符

词法作用域：全局变量会自动提升为全局对象，可以通过全局对象的属性来访问，这样可以访问到被同名表示符遮蔽的外部作用域

函数作用域：每声明一个函数都会为其创建一个函数的作用域，属于这个函数的所有变量都可以在整个函数的范围内使用和复用；通过函数作用域也可以对一些变量进行隐藏，但这样会引发一个问题就是生命的函数名会提升为全局变量污染全局作用域，；函数声明和函数表达式的区别也在于他们的名称标识符会绑定在声明的地方

块级作用域：ES6新增，可随意嵌套





### 闭包

JavaScript中函数内部可以读取外部的变量，但在函数外部无法读取函数内部的变量（函数内部声明变量时一定要使用声明符号比如let和var不然会变成全局变量）；为了在函数外部可以读取函数内部的变量就可以使用闭包在函数内部再定义一个函数，使用这个函数来访问变量操作，然后将这个函数返回；

作用：读取函数内部变量；让这些变量的值始终保存在内存中

始终保存在内存中是因为子函数在外调用，子函数所在的复函数作用域不会被释放，在外部函数执行后，一般他的整个内部作用域都会被垃圾回收机制销毁释放不再使用的内存空间，而闭包可以使他不销毁，因为他本身仍然在使用

闭包满足的两个条件：上下文销毁依然存在，代码中引入了自由变量

应用：匿名自执行函数；结果缓存；模仿块级作用域；单例模式



### this

可以隐式传递一个对象的引用，引用的是函数据以执行的环境对象；this是在运行时绑定的而不是在编写时绑定的，他的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式，当一个函数被调用时，会创建一个活动记录（执行上下文）：这个记录会包含函数在哪里被调用，函数的调用方法，传入的参数信息；this就是记录的其中一个属性，会在函数执行过程中调用

绑定规则（优先级从低到高）

* 默认绑定：默认绑定this指向全局对象
* 隐式绑定：考虑调用位置是否有上下文对象，也就是说是否被某个对象拥有或包含
* 显示绑定：使用call和apply进行强制绑定
* new绑定：函数或方法调用之前带有new关键字造成构造函数的调用







































### 对象的深浅拷贝---各种类型

浅拷贝：比如数组使用slice,contact方法返回一个新数组的特性来实现拷贝，但如果数组中嵌套了对象或者数组，使用contact方法克隆就不完整，只会拷贝对象和数组的引用；浅拷贝使，在新旧数组中修改数据都会引起另一个组数据的改变