# http概念

### 报文

是简单的格式化数据块 ，每条报文都包含一条来自客户端的请求，或者一条来自服务端的响应。

* 由三个部分组成
  * 对报文进行描述的起始行
  * 包含属性的首部块
  * 包含数据的主体部分

```http
<method> <request-URL> <version>
<headers>

<enity-body>
```

请求报文格式

```http
<version> <status> <reason-phrase>
<headers>

<entity-body>
```

响应报文格式

* 方法：客户端希望服务器对资源执行的动作，是一个单独的词。比如GET，HEAD或POST
* 请求URL：命名了所请求的资源，或者URL路径组件的完整URL。
* 版本：值报文所使用的HTTP版本
* 状态码：描述了请求过程中所发生的情况，每一个状态码的第一位数字都用于描述状态的一般类别
* 原因短语：数字状态码的可读版本，包含行终止序列之前的所有文本。
* 首部(header)：可以有0个或多个首部，每一个首部包含一个名字，后面跟着一个冒号，然后是一个可选的空格，接着是一个值，最后是一个CRLF(空行)
* 实体的主体部分：包含一个由任意数据组成的数据块

## 起始行

请求报文的起始行说明了要做些什么，响应报文的起始行说明发生了什么

* 请求行：包含了一个方法和一个请求URL，这个方法描述了服务器该执行的操作，请求URL描述了要对那个资源执行这个方法。还包含了HTTP的版本，用来告知服务器用户端使用的是那种HTTP。所有字段都由空格符分隔。
* 响应行：承载了状态信息和操作所产生的数据结果，并将其返回给客户端。包含了响应报文的HTTP版本，数字状态码以及描述操作状态的文本形式的原因短语。

```http
//请求报文
GET /testhi-there.txt HTTP/1.1
//响应报文
HTTP/1.0 200 OK
```

方法：请求的起始行以方法作为开始，用来告知服务器要做些什么

* GET：从服务器中获取一份文档
* HEAD：从服务器获取文档的首部
* POST：向服务器发送需要处理的数据，包含主体
* PUT：将请求的主体部分储存在服务器上，包含主体
* TRACE：对可能经过代理服务器传送到服务器上去的报文进行追踪
* OPTIONS：决定可以在服务器上执行哪些方法
* DELETE：从服务器上删除一份文档

状态码：100-101：信息提示；200-206：成功；300-305：重定向；400-415：客户端错误；500-505：服务器错误，一般超出定义范围的尾扩展定义

* 100：说明收到了请求的初始部分，请客户端继续，发送了这个状态码之后，服务器在收到请求后必须进行响应
* 101：说明服务器正在根据客户端的指定，将协议换成Update首部所列的协议

---

* 200：请求成功，实体的整体部分包含了所请求的资源
* 201：用于创建服务器对象的请求(比如put)。服务器必须在发送状态码之前创建好对象
* 202：请求已被接收，但服务器还未对其执行任何动作。不保证服务器会完成这个请求
* 203：实体首部包含的信息不是来自于源服务器，而是来自资源的一份副本，如果中间节点上哟一份资源副本，但无法或者没有对它所发送的与资源有关的元信息(首部)进行验证，就会出现这种情况
* 204：响应报文中包含若干首部和一个状态行，但没有实体的主体部分，主要用于在浏览器不转为显示新文档的情况下对其进行更新(比如刷新表单页面)
* 205：主要用于浏览器的代码，负责告知浏览器清除当前页面中的所有html表单元素
* 206：成功执行了一个部分或范围请求。客户端可以通过一些特殊的首部来获取某个部分或范围的文档，这个状态码说明范围请起成功

---

* 300：客户端请求一个实际指向多个资源的URL时会返回这个状态码，比如某个服务器上有文档的英文版和中文版，返回这个代码时会带一个选项列表
* 301：在请求的URL已被移除使用，响应的Location首部中包含资源现在所处的位置。永久重定向
* 302：与301状态码类似，但是客户端用给使用Location首部给出的URL来临时定位资源，将来的请求仍使用老的URL。也叫临时重定向
* 303：告知客户端可以使用另一个url来请求资源，应使用get方法定向获取请求的资源
* 304：客户可以通过所包含的请求首部发送附带条件，但其请求是有条件的，也就是说未符合条件。服务端资源未改变，可直接使用客户端未过期的缓存
* 305：用来说明必须使用一个代理来访问资源
* 307：与302状态码类似，昏遵照浏览器标准，不会从post变为get

---

* 400：该状态码表示请求中存在语法错误
* 401：表示发送的请求需要有通过HTTP认证的认证信息。若之前已进行过一次请求，则表示用户认证失败
* 403：请求资源的访问被服务器拒绝了。
* 404：服务器上没有请求的资源，也就是说服务器无法找到请求的url
* 405：发起请求中带有请求的URL不支持的方法时
* 406：没有与客户端可接受的URL相匹配的资源
* 408：客户端完成请求所花的时间过长
* 409：说明请求可能在资源上引发的一些冲突
* 410：与404类似，客户端曾经拥有过此资源

---

* 500：服务器遇到一个妨碍它为请求提供服务的错误时
* 501：客户端发起的请求超出服务器的能力范围(比如使用了服务器不支持的请求方法)
* 502：作为代理或网关的服务器从请求响应链的下一条链路上收到了一条伪响应(比如无法连接到其父网关)
* 503：服务器暂时处于超负载或停机状态无法为请求提供服务
* 504：响应来自一个网关或代理，在等待另一服务器对其请求响应时超时了
* 505：服务器收到的请求使用了他不愿意支持的协议版本

版本号：为HTTP应用程序提供一种将自己所遵循的协议版本告知对方的方式，老版本协议的应用程序无法实现新版本的特性

## 首部

名字后面跟冒号，然后跟上可选的空格，再跟上字段值，最后一个是CRLF。首部和方法配个工作，共同决定了客户端和服务器能做什么事情

* 通用首部：客户端和服务器都可以使用的首部，在客户端，服务器和其他应用程序之间提供一些通用功能比如Date。既可以出现在请求报文中，也可以出现在响应报文报文中
  * Date：提供日期和时间标志，说明报文是什么时候创建的
* 请求首部：是请求报文特有的，为服务器提供了一些额外的信息，比如客户端希望接收什么类型的数据。
  * 信息性首部
    * Host：给出了接收请求的服务器的主机名和端口号
    * Client-IP：提供了运行客户端的机器的ip地址
    * Referer：提供了包含当前请求URI文档的URL
    * User-Agent：将发起请求的应用程序名称告知服务器
  * Accept首部：为客户端提供了一种将其喜好和能力告诉服务器的方式，服务器不会浪费时间来发送客户端无法使用的东西
    * Accept：告诉服务器能够发送哪些媒体类型
    * Accept-Encoding：服务器能够发送哪些编码方式
  * 条件请求首部：为请求加上某些限制
    * Expect：允许客户端列出某请求所要求的服务器行为
    * If-Match：如果实体标记与文档当前的实体标记相匹配，则获取这份文档
    * Range：如果服务器支持请求范围，就请求资源的指定范围
  * 安全请求首部：可以对请求进行质询/响应认证，要求客户端在获取特定资源之前，先对自身进行认证
    * Authorization：包含了客户端提供给服务器以便对其自身进行认证的数据
    * Cookie：客户端用它向服务器传送一个令牌，包含了安全功能
  * 代理请求首部
    * Proxy-Authorization：与Authorization首部相同，但是在与代理进行认证中使用的
* 响应首部：响应报文自己的首部集，为客户端提供信息，比如客户端在于那种类型的服务器进行交互
  * 信息性首部
    * Age：从创建开始的响应持续时间
    * Server：服务器应用程序软件爱的名称和版本
  * 协商首部：如果资源有多种表示方法，该首部提供了服务器和客户端对资源进行协商的能力
    * Accept-Range：对于此资源来说，服务器可以接受的类型
  * 安全响应首部：就是Http的质询/响应认证机制的响应侧
    * Set-Cookie：可以在客户端设置一个令牌，以便服务器对客户端进行标识
* 实体首部：描述实体的长度和内容，或资源自身，用于应对实体主体部分的首部，比如说明实体部分的数据类型
  * 信息性首部
    * Allow：列出了可以对此实体执行的请求方法
    * Location：告知客户端实体位于何处，用于将接收端定向到资源的位置上去
  * 内容首部：与实体内容有关的特定信息，比如类型尺寸等处理他所需的有用信息
    * Content-Encoding：对主体执行的任意编码方式
    * Content-Length：主体的长度或尺寸
    * Content-Type：主体的对象类型
  * 实体缓存首部
    * Expires：实体不再有效，要从原始的源端再次获取此实体的日期与事件
* 扩展首部：规范中没有定义的新首部

```http
Date:Tue,3Oct 1997 02:16:03 GMT
//服务器产生响应的日期
Content-length:15500
//实体部分包含了15500字节的数据
```

首部延续行：分为多行提高可读性，多处来的每行前面至少要有一个空格或制表符



### 实体的主体

就是http传输的内容

---

### TCP连接

TCP连接为http提供了一条可靠的比特传输管道，从TCP连接一端填入的字节会从另一端以原有的顺序正确地传送出来

Web浏览器通过TCP连接与Web服务器进行交互：浏览器解析出域名 -> 浏览器查询这个主机的IP地址(DNS) -> 浏览器获得端口号 -> 浏览器发起到端口的连接 -> 向服务器发送请求报文 -> 从服务器读取响应报文 -> 关闭连接

* HTTP要传送一条报文时，会以流的形式将报文数据内容通过一条打开的TCP连接按顺序传输，TCP接到数据后会将数据流分解成以端为单位的小数据块，并将段封装在IP分组中通过因特网进行传输
* TCP通过端口号来保持这些连接持续不断地运行。TCP连接是通过四个值来识别的，分别是：源IP地址，源端口号，目的IP地址，目的端口号。这四个值唯一地定义了一条连接，两条不同的TCP连接不能拥有四个完全相同的地址组件值

### 关于TCP的性能



















---



## http各个版本，https

### http1.0，2.0及其新特性

* http1.0支持了各种方法，状态码等；他可以通过content-type支持传输各种数据格式，比如视频音频等二进制文件；必须包括请求头信息

  主要的：每次TCP连接只能发送一个请求，服务器响应之后就会关闭这次连接，下一次连接需要重新建立；也就是说不支持keep-alive;这样的话性能就比较低


* http1.1新增了一些方法比如options；

  * 主要的：加入了持久连接，就是TCP默认不关闭，可以被多个请求复用，当客户端和服务器发现对方没有活动时就会主动关闭链家

  * 加入了管道机制，在同一个TCP连接里允许多个请求同时发送，增强了并发性，客户端可以同时发出两个请求但服务端还是按照顺序回应请求；既然要发出多个响应，就需要一个content-length区分数据包是属于哪一个回应

  * 编码分块传输，如果使用了content-length，就需要等操作完成后才能得知这个length长度，允许分块传输后产生一个数据块就可以发送一块

  * 支持断点传输，1.0都是从头文件开始传输，也就是从0字节，1.1可以使用染个确定传输范围

* http2.0

  * 这是一个二进制协议，因为1.1的头信息是文本，数据可以是文本，而2.0头部和数据都是二进制

  * 采用多路复用技术，客户端和服务器都可以同时发送多个请求或响应，而且数量比1.1大

  * 头信息压缩比如一些重复的字段会进行压缩后发送，cookie，user-agent

  * 服务器推送，不经过客户允许主动发送资源，就是把一些比如静态图片直接推送到客户端，适合让客户端直接从本地加载静态资源



### https(过程)，怎么防止中间人攻击，原理、

* http: 超文本传输协议，是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效
* https: 是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。主要作用是建立一个安全通道，用来确保数组的传输，保证网站的真实性
* 区别：http传输的数据时明文的，https协议是由SSL+HTTP协议构建的可进行加密传输，身份认证的协议网络，想必之下更安全，但https协议的费用较高
* https的工作原理：客户使用https访问服务器，服务器建立ssl连接，服务器接到请求后会将网站的整数传输给客户端。然后双方开始协商一致安全等级，建立会话密匙，通过网站的公钥来加密会话密钥，并传送给网站。web服务器通过自己的私钥解密出会话密钥，通过会话密钥加密与客户端之间的通信。
* https协议的优缺点：保证数据传输过程中数据不被窃取改变。缺点是比较费时，会增加数据开销，ssl证书也比较贵

* 对称加密与非对称加密
  * 对称加密：当客户端发送一个数据，将其加密进行传输，即使中间被劫持了没有密匙也无法知道其中的信息，加密和揭秘为同一个密匙进行就是对称加密
  * 非对称加密：私匙加密的密文只要公匙都可以解密，但公匙加密的密文只要私匙可以解密；也就是说将公匙开放给所有人，私匙存在服务端



---



## cookie,session,localStorage,sessionStorage

#### cookie中包含的字段及作用

* name：cookie的名称
* value：cookie的值
* domain：字段可以访问cookie的域名。顶级域名只能设置domain为顶级域名，不能设置为二级域名或者三级域名，否则cookie无法生存；二级域名能读取设置了domain为顶级域名或者自身的cookie，不能读取其他二级域名domain的cookie，如果cookie想要在多个二级域名中共享，需要设置domain为顶级域名。
* path：字段可以访问此cookie的页面路径，比如domain是abc.com，path是/test，那么只要/test路径下的页面可以读取此cookie
* expires/Max-Age：cookie的超时时间，设置一个时间当到达此时间后此cookie失效，不设置的话默认值是session，也就是和session一起失效，当整个浏览器关闭后就失效
* Size：cookie的带下
* httpOnly：若此属性为true，则只要http请求头中会带有此cookie的信息，不能通过document.cookie来访问此cookie
* secure：设置是否只能通过https来传递词条cookie

#### cookie和session的区别，其他验证方法

* cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递。保存用户登录状态。例如将用户id存储于一个cookie内，这样当用户下次访问该页面时就不需要重新登录了；cookie还可以设置过期时间，当超过时间期限后，cookie就会自动消失；
* cookie将数据存放在客户的浏览器上，session数据存放在服务器上，需要安全考虑的话应该使用cookie，因为攻击者可以分析存放在本地的cookie进行cookie欺骗，而session存放在服务器上，访问量多时会占用服务器性能。**cookie欺骗：CSRF攻击**
* 单个cookie不能超过4k，浏览器第保存的cookie数量也有限制

#### cookie，sessionStorage与localStorage区别

localStorage：储存一对键值对数据在浏览器里面，IE8以下不兼容

相比于cookie：

* 可以保存5M的信息
* 仅在客户端即浏览器中保存，不参与和服务器的通信
* 可采用原生接口，也可再次封装

有效期不同：

* sessionStorage：仅在当前的浏览器窗口关闭前有效
* localStorage：始终有效，窗口或浏览器的关闭也一直保存，因此作持久数据
* cookie：只在设置的cookie过期时间之前一直有效，即使窗口和浏览器关闭

作用域不同：

* sessionStorage：不在不同的浏览器窗口中共享，即使是同一个页面
* localStorage：在所有同源窗口都是共享的
* cookie：在所有的同源窗口中都是共享的

应用场景

* 每次http请求都携带会cookie信息，浪费了带宽，需要指定作用域，不可以跨域调用
* localstorage可以用在页面传递参数，sessionStorage可以用来保存一些临时的数据，防止用户刷新页面后丢失了一些参数

#### CSRF攻击

跨站请求伪造：缩写为CSRF/XSRF。就是用户浏览并登陆可信任的网站后，网站会给他产生一个cookie。用户在没有退出该网站的时候访问另一个危险网站。危险网站发出访问安全网站的请求导致通过用户去cookie访问了安全网站，安全的网站无法分辨请求是谁发出的所以危险网站可以操作安全网站中的用户的操作。

这也就是说，他的流程是登录可信任网站，生成cookie在不登出安全网站的情况下访问危险网站。

**防御方法：**总体的思想是在客户端页面增加伪随机数

* **Cookie.Hashing：**理论上攻击者不能获取第三方的cookie，所以在表单中加入Hash值以确认这是用户发送的请求，然后在服务端进行hash值验证
* **验证码：**每次用户提交都需要在用户表单上填写一个图片上的随机字符串
* **One-Time Tokens：**不同的表单包含 一个不同的伪随机值，需要注意的是并行会话的兼容，如果用户在一个站上同时打开了两个不同的表单，CSRF保护措施不应该影响到他对任何表单的提交，就是用户只能提交他最后的表单，因为其他的表单都含义非法的伪随机值，

#### XSS攻击及预防措施

关于cookie如何防范xss攻击：xss(跨站脚本攻击)，值攻击者在返回的html中嵌入JavaScript脚本，为了减轻这些攻击，需要在HTTP头部配上set-cookie：
* httponly：这个属性禁止JavaScript脚本来访问cookie
* secure：这个属性会告诉浏览器仅在请求https时发送cookie

### SQL注入攻击

就是通过网站输入的内容构造数据库时，攻击者可以通过把sql命令插入到表单提交中从而连接数据库拿到权限等等

**防御方法：**一般是通过正则来防止用户输入有关sql的特殊字符和关键字

---



## 跨域

#### 什么是同源策略，如何实现跨域访问

同源策略：如果两个页面的协议，端口和域名相同，则两个页面具有相同的源。同源策略是一个安全功能，不同客户端脚本在没有明确授权的情况下，不能读取对方的资源。同源策略限制了从同一个源加载的文档如何与来自另一个源的资源进行交互，这是用于隔离潜在恶意文件的重要安全机制

跨域就是指一个域下的脚本试图去请求另一个域下的资源

* 广义的跨域：
  * 资源跳转：a链接，重定向，表单提交
  * 资源嵌入：link,script,img,frame等dom标签，还有样式中的文件外链
  * 脚本请求：js发起的ajax请求，dom和js对象的跨域操作
* 同源策略：指协议+域名+端口三者相同，即使两个不同的域名指向同一个ip地址也不是同源
  * 同源策略限制以下几种行为：Cookie，LocalStorage和IndexDB无法获取；DOM和js对象无法获得；ajax请求不能发送
  * 常见场景：
    * 同一域名，不同文件或路径
    * 同一域名不同端口
    * 同一域名不同协议
    * 域名和域名对应相同ip
    * 主域相同子域不同
    * 不同域名

#### 跨域解决方案

* 通过jsonp跨域：通常为了减轻web服务器的负载，我们把js、css，img等静态资源分离到另一台独立域名的服务器上，在html页面中再通过相应的标签从不同域名下加载静态资源，而被浏览器允许，基于此原理，我们可以通过动态创建script，再请求一个带参网址实现跨域通信

```html
//原生实现
<script>
    var script = document.createElement('script')
    script.type = 'text/javascript'
    //传参一个回调函数名给后端,方便后端返回时执行这个在前端定义的回调函数
    script.src = 'http://www.domain2.com:8080/login?user=admin&callback=handleCallback'
    document.head.appendChild(script)
    //回调执行函数
    function handleCallback(res){
        //...
    }
</script>
```

```js
//vue实现
this.$http.jsonp('http://www.domain2.com:8080/login', {
    params: {},
    jsonp: 'handleCallback'
}).then((res) => {
    console.log(res); 
})
```

缺点：只能实现get一种请求

* document.domain+iframe跨域：实现原理：两个页面都通过js强制设置document.domain为基础主域，就实现了同域
  * 仅限主域相同，子域不同的跨域应用场景
    * 父窗口：http://www.domain.com/a.html
    * 子窗口：http://child.domain.com/b.html

```html
//父窗口
<iframe id="iframe" src="http://child.domain.com/b.html"></iframe>
<script>
    document.domain = 'domain.com';
    var user = 'admin';
</script>
//子窗口
<script>
    document.domain = 'domain.com';
    // 获取父窗口中变量
    alert('get js data from parent ---> ' + window.parent.user);
</script>
```

* location.hash+iframe跨域：a欲与b跨域相互通信，通过中间页c来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。
* window.name+iframe跨域：name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）

* 跨域资源共享(CORS)

```js
//在ajax中设置
xhr.withCredentials = true;
```

* Nginx，Nodejs代理跨域



---



### TCP与UDP协议的区别

* TCP是面向连接的，udp是无连接的，就是发送数据前不需要先建立连接；也就是说tcp是面向连接的可靠传输，udp是不可靠的
* TCP提供可靠服务，通过TCP连接传送的数据，无差错，不丢失，不重复，适合大量数据的交换，且按顺序到达；udp不保证可靠交付
* TCP是面向字节流的；UDP面向报文，并且网络出现阻塞不会使得发送速率降低
* TCP一对一，UDP支持一对一和一对多
* TCP的首部最大为20字节，UDP只有8字节



---



### get与post区别 

* get和post请求传参的长度不是http规定的而是因为浏览器和web服务器限制了URI(统一资源标识符)的长度，不同浏览器和Web服务器的限制最大长度不同
* 在缓存方面的区别
  * get请求类似于查找的过程，用户获取数据可以不用每次都和数据库连接，所以可以使用缓存。(相比于post更适合)
  * post做的一般都是删除和修改的工作，必须和数据库交互，所以不能使用缓存。
* get参数通过url传递，post放在request body中，且get在url中传递的参数是有长度限制的。因为参数直接暴露在url中所以安全性也较低，不适合传递敏感信息。且参数会保存在浏览历史记录中



---



### HTTP缓存(强缓存/协商缓存字段/缓存优先级/浏览器缓存)

* 浏览器缓存：是浏览器在本地磁盘对用户请求过的文档进行缓存，当访问者再次访问同一个页面时，浏览器可以直接从本地磁盘加载文档
  * 特点：减少冗余的数据传输；减少服务器负担；加速客户端加载网页的速度
* 浏览器缓存主要分为强缓存和协商缓存：
  * 强缓存：利用http头中 Expires和Cache-Control两个字段来控制，用来表示资源的缓存事件。强缓存中普通刷新会忽略它，但不会清除它，需要强制刷新。
    * Expires：是一个绝对时间的GMT格式的事件字符串
    * Cache-Control是一个相对时间
  * 协商缓存：是由服务器来确定缓存资源是否可用，所以客户端与服务器要通过某种标识来进行通信，从而让服务器判断请求资源是否可以缓存访问
* 优先级问题：普通刷新会启用弱缓存，忽略强缓存。只有在地址栏或收藏夹输入网址，通过链接引用资源等情况下，浏览器才会启用强缓存



---



### DNS解析与TCP,UDP的关系

DNS同时使用TCP与UDP协议；在区域传输时使用TCP协议，其他时间使用UDP协议；

辅域名服务器会定时向主域名服务器进行查询以了解数据是否变动，如有变动会执行一次区域传送进行数据同步，区域传送使用的是TCP而不是UDP，因为数据同步传送的数据量比一个请求应答的数据量要多得多；TCP是一种可靠连接，保证的数据的准确性

域名解析时使用的是UDP协议，一般返回的内容都不超过512个字节用UDP传输即可，不用经过三次握手，这样DNS服务器负载更低响应更快。客户端也可以指定DNS服务器查询时用TCP。但很多DNS服务器只支持UDP查询



### TCP三次握手四次挥手(为什么要三次握手，在什么情况下会四次挥手)

* 客户端向服务器端发出请求链接，第一次握手，客户端给服务端发送一个带SYN标识的数据包，然后服务端确认自己可以收到这个数据包，然后会给客户端发送数报文段，客户端确认可以收到服务端发送的数据，进行第三次握手，发送给服务端数据让服务端确认客户端收到了自己发送的数据包

### osi七层模型

### http报文内容

是简单的格式化数据块 ，每条报文都包含一条来自客户端的请求，或者一条来自服务端的响应。

* 由三个部分组成，对报文进行描述的起始行；包含属性的首部块；包含数据的主体部分

