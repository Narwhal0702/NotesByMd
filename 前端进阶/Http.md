# http概念

### 报文

是简单的格式化数据块 ，每条报文都包含一条来自客户端的请求，或者一条来自服务端的响应。

* 由三个部分组成
  * 对报文进行描述的起始行
  * 包含属性的首部块
  * 包含数据的主体部分

```http
<method> <request-URL> <version>
<headers>

<enity-body>
```

请求报文格式

```http
<version> <status> <reason-phrase>
<headers>

<entity-body>
```

响应报文格式

* 方法：客户端希望服务器对资源执行的动作，是一个单独的词。比如GET，HEAD或POST
* 请求URL：命名了所请求的资源，或者URL路径组件的完整URL。
* 版本：值报文所使用的HTTP版本
* 状态码：描述了请求过程中所发生的情况，每一个状态码的第一位数字都用于描述状态的一般类别
* 原因短语：数字状态码的可读版本，包含行终止序列之前的所有文本。
* 首部(header)：可以有0个或多个首部，每一个首部包含一个名字，后面跟着一个冒号，然后是一个可选的空格，接着是一个值，最后是一个CRLF(空行)
* 实体的主体部分：包含一个由任意数据组成的数据块

## 起始行

请求报文的起始行说明了要做些什么，响应报文的起始行说明发生了什么

* 请求行：包含了一个方法和一个请求URL，这个方法描述了服务器该执行的操作，请求URL描述了要对那个资源执行这个方法。还包含了HTTP的版本，用来告知服务器用户端使用的是那种HTTP。所有字段都由空格符分隔。
* 响应行：承载了状态信息和操作所产生的数据结果，并将其返回给客户端。包含了响应报文的HTTP版本，数字状态码以及描述操作状态的文本形式的原因短语。

```http
//请求报文
GET /testhi-there.txt HTTP/1.1
//响应报文
HTTP/1.0 200 OK
```

方法：请求的起始行以方法作为开始，用来告知服务器要做些什么

* GET：从服务器中获取一份文档
* HEAD：从服务器获取文档的首部
* POST：向服务器发送需要处理的数据，包含主体
* PUT：将请求的主体部分储存在服务器上，包含主体
* TRACE：对可能经过代理服务器传送到服务器上去的报文进行追踪
* OPTIONS：决定可以在服务器上执行哪些方法
* DELETE：从服务器上删除一份文档

状态码：100-101：信息提示；200-206：成功；300-305：重定向；400-415：客户端错误；500-505：服务器错误，一般超出定义范围的尾扩展定义

* 100：说明收到了请求的初始部分，请客户端继续，发送了这个状态码之后，服务器在收到请求后必须进行响应
* 101：说明服务器正在根据客户端的指定，将协议换成Update首部所列的协议

---

* 200：请求成功，实体的整体部分包含了所请求的资源
* 201：用于创建服务器对象的请求(比如put)。服务器必须在发送状态码之前创建好对象
* 202：请求已被接收，但服务器还未对其执行任何动作。不保证服务器会完成这个请求
* 203：实体首部包含的信息不是来自于源服务器，而是来自资源的一份副本，如果中间节点上哟一份资源副本，但无法或者没有对它所发送的与资源有关的元信息(首部)进行验证，就会出现这种情况
* 204：响应报文中包含若干首部和一个状态行，但没有实体的主体部分，主要用于在浏览器不转为显示新文档的情况下对其进行更新(比如刷新表单页面)
* 205：主要用于浏览器的代码，负责告知浏览器清除当前页面中的所有html表单元素
* 206：成功执行了一个部分或范围请求。客户端可以通过一些特殊的首部来获取某个部分或范围的文档，这个状态码说明范围请起成功

---

* 300：客户端请求一个实际指向多个资源的URL时会返回这个状态码，比如某个服务器上有文档的英文版和中文版，返回这个代码时会带一个选项列表
* 301：在请求的URL已被移除使用，响应的Location首部中包含资源现在所处的位置。永久重定向
* 302：与301状态码类似，但是客户端用给使用Location首部给出的URL来临时定位资源，将来的请求仍使用老的URL。也叫临时重定向
* 303：告知客户端可以使用另一个url来请求资源，应使用get方法定向获取请求的资源
* 304：客户可以通过所包含的请求首部发送附带条件，但其请求是有条件的，也就是说未符合条件。服务端资源未改变，可直接使用客户端未过期的缓存
* 305：用来说明必须使用一个代理来访问资源
* 307：与302状态码类似，昏遵照浏览器标准，不会从post变为get

---

* 400：该状态码表示请求中存在语法错误
* 401：表示发送的请求需要有通过HTTP认证的认证信息。若之前已进行过一次请求，则表示用户认证失败
* 403：请求资源的访问被服务器拒绝了。
* 404：服务器上没有请求的资源，也就是说服务器无法找到请求的url
* 405：发起请求中带有请求的URL不支持的方法时
* 406：没有与客户端可接受的URL相匹配的资源
* 408：客户端完成请求所花的时间过长
* 409：说明请求可能在资源上引发的一些冲突
* 410：与404类似，客户端曾经拥有过此资源

---

* 500：服务器遇到一个妨碍它为请求提供服务的错误时
* 501：客户端发起的请求超出服务器的能力范围(比如使用了服务器不支持的请求方法)
* 502：作为代理或网关的服务器从请求响应链的下一条链路上收到了一条伪响应(比如无法连接到其父网关)
* 503：服务器暂时处于超负载或停机状态无法为请求提供服务
* 504：响应来自一个网关或代理，在等待另一服务器对其请求响应时超时了
* 505：服务器收到的请求使用了他不愿意支持的协议版本

版本号：为HTTP应用程序提供一种将自己所遵循的协议版本告知对方的方式，老版本协议的应用程序无法实现新版本的特性

## 首部

名字后面跟冒号，然后跟上可选的空格，再跟上字段值，最后一个是CRLF。首部和方法配个工作，共同决定了客户端和服务器能做什么事情

* 通用首部：客户端和服务器都可以使用的首部，在客户端，服务器和其他应用程序之间提供一些通用功能比如Date。既可以出现在请求报文中，也可以出现在响应报文报文中
  * Date：提供日期和时间标志，说明报文是什么时候创建的
* 请求首部：是请求报文特有的，为服务器提供了一些额外的信息，比如客户端希望接收什么类型的数据。
  * 信息性首部
    * Host：给出了接收请求的服务器的主机名和端口号
    * Client-IP：提供了运行客户端的机器的ip地址
    * Referer：提供了包含当前请求URI文档的URL
    * User-Agent：将发起请求的应用程序名称告知服务器
  * Accept首部：为客户端提供了一种将其喜好和能力告诉服务器的方式，服务器不会浪费时间来发送客户端无法使用的东西
    * Accept：告诉服务器能够发送哪些媒体类型
    * Accept-Encoding：服务器能够发送哪些编码方式
  * 条件请求首部：为请求加上某些限制
    * Expect：允许客户端列出某请求所要求的服务器行为
    * If-Match：如果实体标记与文档当前的实体标记相匹配，则获取这份文档
    * Range：如果服务器支持请求范围，就请求资源的指定范围
  * 安全请求首部：可以对请求进行质询/响应认证，要求客户端在获取特定资源之前，先对自身进行认证
    * Authorization：包含了客户端提供给服务器以便对其自身进行认证的数据
    * Cookie：客户端用它向服务器传送一个令牌，包含了安全功能
  * 代理请求首部
    * Proxy-Authorization：与Authorization首部相同，但是在与代理进行认证中使用的
* 响应首部：响应报文自己的首部集，为客户端提供信息，比如客户端在于那种类型的服务器进行交互
  * 信息性首部
    * Age：从创建开始的响应持续时间
    * Server：服务器应用程序软件爱的名称和版本
  * 协商首部：如果资源有多种表示方法，该首部提供了服务器和客户端对资源进行协商的能力
    * Accept-Range：对于此资源来说，服务器可以接受的类型
  * 安全响应首部：就是Http的质询/响应认证机制的响应侧
    * Set-Cookie：可以在客户端设置一个令牌，以便服务器对客户端进行标识
* 实体首部：描述实体的长度和内容，或资源自身，用于应对实体主体部分的首部，比如说明实体部分的数据类型
  * 信息性首部
    * Allow：列出了可以对此实体执行的请求方法
    * Location：告知客户端实体位于何处，用于将接收端定向到资源的位置上去
  * 内容首部：与实体内容有关的特定信息，比如类型尺寸等处理他所需的有用信息
    * Content-Encoding：对主体执行的任意编码方式
    * Content-Length：主体的长度或尺寸
    * Content-Type：主体的对象类型
  * 实体缓存首部
    * Expires：实体不再有效，要从原始的源端再次获取此实体的日期与事件
* 扩展首部：规范中没有定义的新首部

```http
Date:Tue,3Oct 1997 02:16:03 GMT
//服务器产生响应的日期
Content-length:15500
//实体部分包含了15500字节的数据
```

首部延续行：分为多行提高可读性，多处来的每行前面至少要有一个空格或制表符



### 实体的主体

就是http传输的内容

---

### TCP连接

TCP连接为http提供了一条可靠的比特传输管道，从TCP连接一端填入的字节会从另一端以原有的顺序正确地传送出来

Web浏览器通过TCP连接与Web服务器进行交互：浏览器解析出域名 -> 浏览器查询这个主机的IP地址(DNS) -> 浏览器获得端口号 -> 浏览器发起到端口的连接 -> 向服务器发送请求报文 -> 从服务器读取响应报文 -> 关闭连接

* HTTP要传送一条报文时，会以流的形式将报文数据内容通过一条打开的TCP连接按顺序传输，TCP接到数据后会将数据流分解成以端为单位的小数据块，并将段封装在IP分组中通过因特网进行传输
* TCP通过端口号来保持这些连接持续不断地运行。TCP连接是通过四个值来识别的，分别是：源IP地址，源端口号，目的IP地址，目的端口号













# Http面试部分

# 关于HTML的面试

### http1.0，2.0及其新特性

* 是对http1.0的更新，提升了访问速度，允许多路复用，在http1中同一时间内针对同一域名下的请求有数量限制；2.0会将传输信息分割，进行二进制编码，这样可以加快传输速度；会对首部进行一个压缩

### http的请求类型，请求字段

### https(过程)，怎么防止中间人攻击，原理、

* http: 超文本传输协议，是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效
* https: 是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。主要作用是建立一个安全通道，用来确保数组的传输，保证网站的真实性
* 区别：http传输的数据时明文的，https协议是由SSL+HTTP协议构建的可进行加密传输，身份认证的协议网络，想必之下更安全，但https协议的费用较高
* https的工作原理：客户使用https访问服务器，服务器建立ssl连接，服务器接到请求后会将网站的整数传输给客户端。然后双方开始协商一致安全等级，建立会话密匙，通过网站的公钥来加密会话密钥，并传送给网站。web服务器通过自己的私钥解密出会话密钥，通过会话密钥加密与客户端之间的通信。
* https协议的优缺点：保证数据传输过程中数据不被窃取改变。缺点是比较费时，会增加数据开销，ssl证书也比较贵

### TCP三次握手四次挥手(为什么要三次握手，在什么情况下会四次挥手)

* 客户端向服务器端发出请求链接，第一次握手，客户端给服务端发送一个带SYN标识的数据包，然后服务端确认自己可以收到这个数据包，然后会给客户端发送数报文段，客户端确认可以收到服务端发送的数据，进行第三次握手，发送给服务端数据让服务端确认客户端收到了自己发送的数据包

### osi七层模型

### http报文内容

是简单的格式化数据块 ，每条报文都包含一条来自客户端的请求，或者一条来自服务端的响应。

* 由三个部分组成，对报文进行描述的起始行；包含属性的首部块；包含数据的主体部分

### cookie和session的区别，其他验证方法

* cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递。保存用户登录状态。例如将用户id存储于一个cookie内，这样当用户下次访问该页面时就不需要重新登录了；cookie还可以设置过期时间，当超过时间期限后，cookie就会自动消失；
* cookie将数据存放在客户的浏览器上，session数据存放在服务器上，需要安全考虑的话应该使用cookie，因为攻击者可以分析存放在本地的cookie进行cookie欺骗，而session存放在服务器上，访问量多时会占用服务器性能
* 单个cookie不能超过4k，浏览器第保存的cookie数量也有限制

### sessionStorage与localStorage区别

相比于cookie：

* 可以保存5M的信息
* 仅在客户端即浏览器中保存，不参与和服务器的通信
* 可采用原生接口，也可再次封装

有效期不同：

* sessionStorage：仅在当前的浏览器窗口关闭前有效
* localStorage：始终有效，窗口或浏览器的关闭也一直保存，因此作持久数据
* cookie：只在设置的cookie过期时间之前一直有效，即使窗口和浏览器关闭

作用域不同：

* sessionStorage：不在不同的浏览器窗口中共享，即使是同一个页面
* localStorage：在所有同源窗口都是共享的
* cookie：在所有的同源窗口中都是共享的

应用场景

* 每次http请求都携带会cookie信息，浪费了带宽，需要指定作用域，不可以跨域调用
* localstorage可以用在页面传递参数，sessionStorage可以用来保存一些临时的数据，房主用户刷新页面后丢失了一些参数

### TCP与UDP协议的区别

* TCP是面向连接的，udp是无连接的，就是发送数据前不需要先建立连接；也就是说tcp是面向连接的可靠传输，udp是不可靠的
* TCP提供可靠服务，通过TCP连接传送的数据，无差错，不丢失，不重复，适合大量数据的交换，且按顺序到达；udp不保证可靠交付
* TCP是面向字节流的；UDP面向报文，并且网络出现阻塞不会使得发送速率降低
* TCP一对一，UDP支持一对一和一对多
* TCP的首部最大为20字节，UDP只有8字节

### DNS解析原理

### get与post区别 

* get和post请求传参的长度不是http规定的而是因为浏览器和web服务器限制了URI(统一资源标识符)的长度，不同浏览器和Web服务器的限制最大长度不同
* 在缓存方面的区别
  * get请求类似于查找的过程，用户获取数据可以不用每次都和数据库连接，所以可以使用缓存。(相比于post更适合)
  * post做的一般都是删除和修改的工作，必须和数据库交互，所以不能使用缓存。
* get参数通过url传递，post放在request body中，且get在url中传递的参数是有长度限制的。因为参数直接暴露在url中所以安全性也较低，不适合传递敏感信息。且参数会保存在浏览历史记录中

### 状态码（301与302区别，304缓存的原理）

### 缓存(强缓存/协商缓存字段/缓存优先级/浏览器缓存)

* 浏览器缓存：是浏览器在本地磁盘对用户请求过的文档进行缓存，当访问者再次访问同一个页面时，浏览器可以直接从本地磁盘加载文档
  * 特点：减少冗余的数据传输；减少服务器负担；加速客户端加载网页的速度
* 浏览器缓存主要分为强缓存和协商缓存：
  * 强缓存：利用http头中 Expires和Cache-Control两个字段来控制，用来表示资源的缓存事件。强缓存中普通刷新会忽略它，但不会清除它，需要强制刷新。
    * Expires：是一个绝对时间的GMT格式的事件字符串
    * Cache-Control是一个相对时间
  * 协商缓存：是由服务器来确定缓存资源是否可用，所以客户端与服务器要通过某种标识来进行通信，从而让服务器判断请求资源是否可以缓存访问
* 优先级问题：普通刷新会启用弱缓存，忽略强缓存。只有在地址栏或收藏夹输入网址，通过链接引用资源等情况下，浏览器才会启用强缓存

### XSS及CROS攻击及预防措施

* 关于cookie如何防范xss攻击：xss(跨站脚本攻击)，值攻击者在返回的html中嵌入JavaScript脚本，为了减轻这些攻击，需要在HTTP头部配上set-cookie：
  * httponly：这个属性禁止JavaScript脚本来访问cookie
  * secure：这个属性会告诉浏览器仅在请求https时发送cookie

### 什么是同源策略，如何实现跨域访问

同源策略：如果两个页面的协议，端口和域名相同，则两个页面具有相同的源。同源策略是一个安全功能，不同客户端脚本在没有明确授权的情况下，不能读取对方的资源。同源策略限制了从同一个源加载的瘟当如何与来自另一个源的资源进行交互，这是用于隔离潜在恶意文件的重要安全机制

跨域就是指一个域下的脚本试图去请求另一个域下的资源

### 从输入一个url到页面渲染的全过程

首先需要找到这个url域名的服务器ip，为了找到这个ip，浏览器会先寻找缓存，查看缓存中是否有记录，缓存中没有就直接查找系统中的host文件是否有记录，如果没有则查询DNS服务器，得到服务器的ip地址后，浏览器根据这个ip以及相应的端口号构造一个http请求，这个请求报文会包括这次请求的信息，主要是请求的方法，请求说明和请求附带的数据

* DNS解析:将域名地址解析为ip地址
* 客户端根据ip地址连接到Web服务器
* TCP连接，三次握手
* 发送请求
* 接收响应，定位请求资源，执行请求分析，然后返回一个http响应。
* 渲染页面：浏览器把html节点遍历为dom数，将css解析成css dom树，将两个树构造成render树；js根据得到的render树计算所有节点在屏幕中的位置，进行布局；遍历render树并绘制所有的节点
* 断开连接：四次挥手释放tcp连接，若连接模式为close，则服务器主动关闭tcp连接，客户端被动关闭，若connection为keepalive，则连接会保持一段时间，在该时间内可以继续请求

