# JS数据结构

## 关于数组

* 求斐波那锲数列的前二十个数字。斐波那锲(第一个数字是1，第二个是2，其他每个都是前两个数字之和)

```js
var fibonacci = [];
fibonacci[0] = 1;
fibonacci[1] = 2;
for(let i = 2;i < 20;i++){
    fibonacci[i] = fibonacci[i-1] + fibonacci[i-2];
}
for(let i = 0;i < fibonacci.length;i++){
	console.log(fibonacci[i]);
}
```

* JavaScript只支持一维数组，但可以通过数组嵌套来实现矩阵或多维数组

### 关于数组的各种方法

* push()：把任意个元素添加到数组的末尾
* unshift()：可以直接把数值插入数组的首位
* pop()：删除数组最后的元素
* shift()：删除数组的第一个元素
* splice()：在任意位置添加或删除元素。第一个参数表示想要删除或插入的元素的索引值第二个参数是删除元素的个数(若不删除则传入0)，第三个以及以后参数都是要添加到数组中的元素
* contact()：连接两个或更多个数组，并返回结果
* every()：对数组的每一项运行给定函数，如果该函数对每一项都返回true，则返回true
* filter()：对数组的每一项运行给定函数，该函数会返回true项形成的数组
* forEach()：对数组的每一项运行给定函数，没有返回值
* join()：将所有数组连接成一个字符串，参数填入分隔符
* indexOf()：返回一个与给定参数相等对数组元素索引，没有找到则返回-1
* lastIndexOf()：返回在数组中搜索到的与给定参数相等的元素索引里的最大值
* map()：对数组每一项运行给定函数，返回每次函数调用后结果组成的数组
* reverse()：反转数组
* slice()：传入索引值，将数组里对应索引范围内的元素作为新数组返回
* some()：对数组的每一项运行给定函数，如果任意一项返回true则返回true
* sort()：按照书序对数组进行排序，支持传入指定排序方法的函数作为参数
* toString()：将数组作为字符串返回
* valueOf()：和toString类似，将数组作为字符串返回。区别于他返回的是原始类型的值(数值，字符串，布尔值等)
* @@iterator：返回一个包含数组键值对的迭代器对象，可以通过同步调用得到数组元素的键值对
* copyWithin()：赋值数组元素中一系列元素到到同一数组指定的起始位置。参数分别为复制到指定目标索引位置，元素的起始位置，停止复制的索引位置。
* ertires()：返回包含数组所有键值对的@@iterator
* includes()：如果数组中存在某个元素则返回true，否则返回false
* find()：根据回调函数给定的条件从数组中查找元素，如果找到则返回该元素
* findIndex()：根据回调函数给定的条件从数组中查找元素，如果找到则返回该元素的索引
* fill()：使用静态值填充数组
* from()：根据已有数组创建一个新数组
* keys()：返回包含数组所有索引的@@iterator
* of()：根据传入的参数创建一个新数组
* values()：返回数组中所有值的@@iterator





## 关于栈

```js
function Stack(){
	var arr = []
	this.push = function(item){
		arr.push(item)
	}
	this.pop = function(){
		return arr.pop()
	}
	Stack.prototype.peek = function(){
		return arr[arr.length-1]
	}
	Stack.prototype.isEmpty = function(){
		return arr.length == 0;
	}
	Stack.prototype.clear = function(){
		arr.length = 0;
		//arr = [];
	}
	Stack.prototype.size = function(){
		return arr.length
	}
	Stack.prototype.show = function(){
		return arr.toString();
	}
}
//使用Stack.prototype来代替this;前者给整个类添加了方法(共享方法),后者给实例添加方法(每一个都有添加方法).前者更节省时间和内存
//十进制与二进制间的转换
function divByTwo(num){
	var stack = new Stack();
	var rem=0;
	var result = "";
	while(num > 0){
		rem = num%2;
		stack.push(rem);
		num = Math.floor(num/2)
	}
	while(!stack.isEmpty()){
		result += stack.pop();
	}
	return result;
}
console.log(divByTwo(110))
```

使用Stack语法声明Stack类

```js
class Stack{
	constructor() {
	    this.items = [];
	}
	push(element){
		this.items.push(element)
	}
	//...
}
```

基于原型的类比基于函数更节省内存也更适合创建多个实例，却不能声明私有属性和方法。希望用户只能访问暴露给类的方法

```js
//方法1:使用ES6限定作用域Symbol实现,要访问_items,只需把所有this.items换成this[_items]
//这个方法创建了一个假的私有属性,因为ES6新增的Object.getOwnPropertySymbols方法能够获取到类里面声明的所有Symbol属性
let _items = Symbol();
class Stack{
	constructor() {
	    this[_items] = [];
	}
	//methods...
}
//方法2:使用WeakMap实现类
let Stack = (function () {
	const items = new WeakMap();
	class Stack{
		constructor() {
		    items.set(this,[])
		}
		push(element){
			let s = items.get(this);
			s.push(element)
		}
		pop(){
			let s = items.get(this);
			let r = this.pop()
			return r;
		}
		//...
	}
	return Stack;
})()
```



## 关于队列

```js

```





