## 浏览器输入url地址到页面渲染的过程

**1、输入url后客户端发送域名给DNS服务器解析为ip地址，然后将IP地址返回给浏览器**

​	TCP/IP协议根据IP地址进行访问的，所以需要将域名请求为ip地址

**2、客户端根据IP地址连接到Web服务器**

一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（HTTP请求默认端口为80）建立一个TCP套接字连接。

**3、三次握手建立TCP连接后发送HTTP请求**

通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据4部分组成。

​	**浏览器与服务器的交互过程**

​		1）首先浏览器利用tcp协议通过三次握手与服务器建立连接

　　http请求包括header和body。header中包括请求的方式（get和post）、请求的协议 （http、https、			ftp）、请求的地址ip、缓存cookie。body中有请求的内容。

　　2）浏览器根据解析到的IP地址和端口号发起http的get请求.

　　3）服务器接收到http请求之后，开始搜索html页面，并使用http返回响应报文

　　4）若状态码为200显示响应成功，浏览器接收到返回的html页面之后，开始进行页面的渲染

**4、服务器接受到请求并返回HTTP响应报文**

Web服务器解析请求，定位请求资源，然后执行请求分析，查找数据库等操作后并返回一个HTTP响应。服务器将资源复本写到TCP套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据4部分组成。

**5、四次挥手释放连接TCP连接**

若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接;

若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求;

**6、客户端浏览器解析HTML内容**

客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。

​		**浏览器页面渲染过程**

　　1）浏览器根据深度遍历的方式把html节点遍历成dom 树

　　2）将css解析成CSS DOM树

　　3）将dom树和CSS DOM树构造成render树

　　4）JS根据得到的render树 计算所有节点在屏幕中的位置，进行布局（回流）

　　5）遍历render树并调用硬件API绘制所有节点（重绘）

## 关于ES6中的Symbol，他为了解决什么问题(详见ES6_Symbol)

* ES5的对象属性名都是字符串，容易造成属性名的冲突。Symbol类型表示独一无二的值。通过Symbol函数生成。他通过Symbol函数生成。它主要解决的问题也就是属性名冲突的问题，因为每一个Symbol值都是不相等的。所以他可以作为标识符用于对象的属性名。
* 这就对一个对象由多个模块构成的情况非常有用，能防止某一个键不小心被改写或覆盖。
* 补充：Symbol值作为对象属性名时不能使用点运算符。因为点运算符后面总是字符串，所以会导致某属性的属性名是字符串而不是Symbol值，这样使用方括号内的Symbol值就无法访问到了。Symbol作为属性名时需要使用[]包裹

## 关于map和set(详见ES6_Set和Map数据结构)

* set类似于数组，但是成员都是唯一的，没有重复
  * 附：向Set加入值时不会发生类型转换，所以"5"和5是两个不同的值，在Set中NaN等于自身，精确相等运算符NaN不等于自身
* mapMap结构实现了值-值的对应，JavaScript的对象本质是键值对的集合(Hash结构)，但是只能用字符串作为键。Map类似于对象也是键值对的集合，但是键的范围不限于字符串，各种类型的值都可以当做键。
* WeakSet
  * 结构与Set类似，也是不重复的值的集合。
  * 成员只能是对象，WeakSet中的对象都是弱引用，即垃圾回收机制不考虑WeakSet对该对象的引用
* WeakMap
  * 与map结构类似，也用于生成键值对的集合
  * WeakMap只接受对象作为键名(null除外)，键名所指向的对象不计入垃圾回收机制

## vue实现数据绑定的原理

* 实现数据绑定主要是实现两个方面的功能：数据导致视图变化，视图变化导致数据变化。后者就是监听视图的事件，然后唉回调函数中改变数据。终重点是数据变化时如何改变视图
  * 思路：通过object.defineProperty()来对数据的属性设置一个set函数，设置后当数据改变时set函数就会被调用，我们就可以里面进行视图更新操作。

## 关于defineProperty的缺陷，以及怎么解决这个问题

使用Proxy解决该问题

* 修改属性默认的特性，该方法接收三个参数，分别是属性所在的对象，属性的名字和一个描述符对象。描述符对象的属性必须是configurable,enumerable,writable和value。设置其中的一个或多个值，可以修改对应的特性值
* 把configurable属性设为false，表示不能从对象中删除属性。如果对这个属性调用delete，在严格模式下回导致错误。一旦把属性定义为不可配置的，就不能把它再变回可配置了。此时再调用该方法修改writable之外的特性都会导致错误
* 他的缺陷：
  * Object.defineProperty无法监控到数组下标的变化，导致通过数组下标添加元素，不能实时响应；
  * Object.defineProperty只能劫持对象的属性，从而需要对每个对象，每个属性进行遍历，如果，属性值是对象，还需要深度遍历。Proxy可以劫持整个对象，并返回一个新的对象。
  * Proxy不仅可以代理对象，还可以代理数组。还可以代理动态增加的属性。
* 有关于vue
  * vue3.0之前的版本都是使用该方法来实现数据的响应式，通过设定对象属性getter/setter方法来监听数据的变化，同时getter也用于依赖收集，而setter在数据变更时通知订阅者更新视图
  * 缺陷：
    * 无法检测到对象属性的新增或删除：由于js的动态性，可以为对象追加新的属性或者删除其中某个属性，这点对经过Object.defineProperty方法建立的响应式对象来说，只能追踪对象已有数据是否被修改，无法追踪新增属性和删除属性，这就需要另外处理
    * 不能监听数组的变化

## vuex的工作流程

简单地来说当遇到多个组件共享状态时，单向数据流的间接性很容易被破坏。比如多个视图依赖于同一状态，不同视图的行为需要变更同一状态。

可以将组件的共享状态抽取出来，以一个全局单例模式管理。通过定义和隔离状态管理中的各种概念，并通过强制规则维持视图和状态间的独立性，我们的代码将会变得更结构化且易维护。

就是创建一个store，然后通过在Vue组件中访问this.$store。

## 重绘与重排

* document.write：重排整个页面；innerHTML：重绘页面的一部分
* 浏览器的运行机制：
  * 构建DOM树：渲染引擎解析html文档，首先将标签转换成DOM树中的DOM节点(包括js生成的标签)生成内容树
  * 构建渲染树：解析对应的css样式文件，以及html中可见的指令，比如b标签之类的，构建渲染树
  * 布局渲染树：从根节点递归调用，计算每一个元素的大小位置，给出每个节点所应该在屏幕上出现的精确位置
  * 绘制渲染树：遍历渲染树，绘制每个节点

**重绘：**当盒子的位置，大小以及其他属性(比如颜色，字体大小)都确定下来之后，浏览器把这些原色都按照各自的特性绘制一遍，将内容呈现在页面上。重绘是指一个元素外观的改变所触发的浏览器行为，浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。触发重绘的条件：改变元素的外观属性如color,background-color等

**重排：**当渲染树中的一部分或全部因为元素的规模尺寸，布局，隐藏等改变而需要重新构建，这就是重排。每个页面至少需要一次重排，就是在页面第一次加载的时候

**两者关系：**在重排的时候，浏览器会使渲染树中受到影响的部分失效，并重新构造这部分渲染树。完成回流后，浏览器重新绘制受影响的部分到屏幕中，这个过程就是重绘。也就是说重排必定会引发重绘，重绘不一定会引发重排。

**重排的条件：**页面初始渲染；添加或删除可见的DOM元素；元素位置改变或使用动画；元素尺寸的改变;浏览器窗口尺寸的变化(触发resize事件)；填充内容的改变；读取某些元素属性等等

**优化：**

* 浏览器方面的优化：会自动把会引起重绘与重排的操作放入一个队列，等到达一定数量或一定时间间隔，对这些操作进行一个批处理
* 其他优化：减少对渲染树的操作，合并多次的DOM和样式修改
  * 直接改变元素的calssName
  * 先设置元素为display:none，然后进行页面布局等操作，设置完成后将元素设置为display:block，这样只会引发两次重绘与重排
  * 将需要多次重排的元素，position属性设为absolute或fixed，元素脱离了文档流，它的变化不会影响到其他元素

## 虚拟DOM

**真实DOM：**在传统的开发中，原生js或jQuery操作DOM时，浏览器会从构建DOM树开始从头到尾执行一遍流程。比如需要更新10个DOM节点，浏览器接收到第一个DOM就会马上执行，最后执行十次，就比如修改节点的坐标，这样会造成性能的浪费

**虚拟DOM：**比如操作中有十个更新DOM对象的动作，虚拟DOM不会立即操作DOM，而是将这十次更新的diff内容保存到一个本地的js对象中，最终将这个js对象一次性关联到DOM树上再进行后续操作，这样相比于真实DOM可以减少计算量

## symbol的用途

主要是作为标识符用于对象的属性名，保证不会出现相同的属性名，这对于一个对象由多个模块构成的情况非常有用；其次可以保证switch语句按照设计的方式工作

## 箭头函数和匿名函数的区别（会不会发生函数声明提升？）

**带名函数和匿名函数的区别：**匿名函数需要将地址值赋值给一个变量，然后通过该变量来调用函数。带名函数直接可以使用函数名调用

**箭头函数和匿名函数的区别：**主要是this指向的问题，箭头函数的this指向定义时所在的环境也就是包裹他的上下文，如果没有则指向window，匿名函数的执行环境是全局的也就是说this指向window。

把匿名函数赋值给变量定义函数的方法叫函数表达式，函数表达式没有函数声明提升。箭头函数也类似于匿名函数没有函数声明提升

## 准确判断一个对象是不是数组

* 通过一个Array.prototype.isPrototypeOf(obj)方法，判断Array是不是在obj的原型链中，如果是则返回true，不是则返回false
* 通过构造函数：obj instanceof Array
  * typeof 和instanceof区别：
* 根据对象的class属性，跨原型链调用toString方法
* Array.isArray()

## css单位

* px：像素
* em：1em为字体当前尺寸，2em为字体尺寸的两倍、
* ex：一个ex是一个字体的x-height(x-height通常是字体尺寸的一般)
* %：百分比
* rem：相对与根节点html的字体大小来计算
* vw：视窗宽度：1vw等于视窗宽度的1%
* vh：视窗高度：1vh等于视窗高度的1%

## 垃圾收集

## 动画

## 不兼容ES6怎么办

安装babel并将其引入到script中

## 清除浮动 

浮动是css中的一个属性float，块级元素可以通过该属性实现左右浮动，目的是让div实现类似表格行和列横竖排布，但是浮动时其他块元素会占用原来位置(对后面元素产生影响)，也就是说浮动会脱离文档流将其他的元素挤走

清除浮动方法：

* 使用带clear属性的空元素：在浮动元素后使用一个空元素如\<div class="clear"\>\</div\>，并在CSS中赋予.clear{clear:both;}属性即可清理浮动。亦可使用\<br class="clear" /\>或\<hr class="clear" />来进行清理。
* 使用css的overflow属性：给浮动元素的容器添加overflow:hidden;或overflow:auto;可以清除浮动，在添加overflow属性后，浮动元素又回到了容器层，把容器高度撑起，达到了清理浮动的效果。
* 给浮动的元素容器添加浮动：给浮动元素的容器也添加上浮动属性即可清除内部浮动，但是这样会使其整体浮动，影响布局，不推荐使用
* 使用相邻元素处理：什么都不做，给浮动元素后面的元素添加clear属性
* 使用css的:after伪元素：给浮动元素的容器添加一个clearfix的class，然后给这个class添加一个:after伪元素实现元素末尾添加一个看不见的块元素（Block element）清理浮动

## 跨域

跨域是指一个域下的文档或脚本试图去请求另一个域下的资源

* 广义的跨域：
  * 资源跳转：a链接，重定向，表单提交
  * 资源嵌入：link,script,img,frame等dom标签，还有样式中的文件外链
  * 脚本请求：js发起的ajax请求，dom和js对象的跨域操作
* 同源策略：指协议+域名+端口三者相同，即使两个不同的域名指向同一个ip地址也不是同源
  * 同源策略限制以下几种行为：Cookie，LocalStorage和IndexDB无法获取；DOM和js对象无法获得；ajax请求不能发送
  * 常见场景：
    * 同一域名，不同文件或路径
    * 同一域名不同端口
    * 同一域名不同协议
    * 域名和域名对应相同ip
    * 主域相同子域不同
    * 不同域名

### 解决方案

* 通过jsonp跨域：通常为了减轻web服务器的负载，我们把js、css，img等静态资源分离到另一台独立域名的服务器上，在html页面中再通过相应的标签从不同域名下加载静态资源，而被浏览器允许，基于此原理，我们可以通过动态创建script，再请求一个带参网址实现跨域通信

```html
//原生实现
<script>
    var script = document.createElement('script')
    script.type = 'text/javascript'
    //传参一个回调函数名给后端,方便后端返回时执行这个在前端定义的回调函数
    script.src = 'http://www.domain2.com:8080/login?user=admin&callback=handleCallback'
    document.head.appendChild(script)
    //回调执行函数
    function handleCallback(res){
        //...
    }
</script>
```

```js
//vue实现
this.$http.jsonp('http://www.domain2.com:8080/login', {
    params: {},
    jsonp: 'handleCallback'
}).then((res) => {
    console.log(res); 
})
```

缺点：只能实现get一种请求

* document.domain+iframe跨域：实现原理：两个页面都通过js强制设置document.domain为基础主域，就实现了同域
  * 仅限主域相同，子域不同的跨域应用场景
    * 父窗口：http://www.domain.com/a.html
    * 子窗口：http://child.domain.com/b.html

```html
//父窗口
<iframe id="iframe" src="http://child.domain.com/b.html"></iframe>
<script>
    document.domain = 'domain.com';
    var user = 'admin';
</script>
//子窗口
<script>
    document.domain = 'domain.com';
    // 获取父窗口中变量
    alert('get js data from parent ---> ' + window.parent.user);
</script>
```

* location.hash+iframe跨域：a欲与b跨域相互通信，通过中间页c来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。
* window.name+iframe跨域：name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）

* 跨域资源共享(CORS)

```js
//在ajax中设置
xhr.withCredentials = true;
```

* Nginx，Nodejs代理跨域

## 响应式布局常见解决方案

* 基础概念：
  * 像素：是网页布局的基础，一个像素表示了计算机屏幕所能显示的最小区域，像素分为css像素和物理像素。在js或css代码中使用的px单位就是css像素，物理像素也称设备像素，只与设备的硬件密度相关，任何设备的物理像素都是固定的
  * 视口：只浏览器显示内容的屏幕区域
    * 布局视口
      * 布局视口定义了pc网页在移动端的默认布局行为，也就是说在不设置网页的viewport的情况下，pc端的网页默认会以布局视口为基准，在移动端进行展示
    * 视觉视口
      * 视觉视口表示浏览器内看到的网站的显示区域，用户可以通过缩放来查看网页的显示内容，从而改变视觉视口。
    * 理想视口
      * 在移动设备中就是指设备的分辨率。换句话说，理想视口或者说分辨率就是给定设备物理像素的情况下，最佳的“布局视口”。

* px和视口
  * 1个css像素可以表示为物理像素/分辨率，如在iphone6移动端一个css像素为0.75px而在pc端则为2px
* 媒体查询
  * 在css文件中，1px所表示的物理像素的大小是不同的，因此通过一套样式，是无法实现各端的自适应，所以给每一种设备设置一套不同的样式来实现自适应效果

```css
@media screen and (max-width: 960px){
    body{
      background-color:#FF6699
    }
}

@media screen and (max-width: 768px){
    body{
      background-color:#00FF66;
    }
}
```

缺点：在浏览器大小改变时，需要改变的样式太多，那么多套样式代码会很繁琐

* 百分比
  * 子元素height和width的百分比：子元素的height或width中使用百分比，是相对于子元素的直接父元素，width相对于父元素的width，height相对于父元素的height。
  * top和bottom 、left和right：子元素的top和bottom如果设置百分比，则相对于直接非static定位(默认定位)的父元素的高度，同样，子元素的left和right如果设置百分比，则相对于直接非static定位(默认定位的)父元素的宽度
  * padding：子元素的padding如果设置百分比，不论是垂直方向或者是水平方向，都相对于直接父亲元素的width，而与父元素的height无关。子元素的初始宽高为0，通过padding可以将父元素撑大，说明padding不论宽高，如果设置成百分比都相对于父元素的width
  * margin：跟padding一样，margin也是如此，子元素的margin如果设置成百分比，不论是垂直方向还是水平方向，都相对于直接父元素的width。
  * border-radius：border-radius不一样，如果设置border-radius为百分比，则是相对于自身的宽度
  * 缺点：
    * 计算困难，如果我们要定义一个元素的宽度和高度，按照设计稿，必须换算成百分比单位
    * 各个属性中如果使用百分比，相对父元素的属性并不是唯一的

* 通过rem来实现响应式布局
  * rem单位都是相对于根元素html的font-size来决定大小的,根元素的font-size相当于提供了一个基准，当页面的size发生变化时，只需要改变font-size的值，那么以rem为固定单位的元素的大小也会发生响应的变化。如果通过rem来实现响应式的布局，只需要根据视图容器的大小，动态的改变font-size即可
  * 可通过webpack实现一些单位之间的转换
  * 缺点：在响应式布局中，必须通过js来动态控制根元素font-size的大小，具有一定的耦合性，且font-size的代码要放在样式之前
* 通过vw/vh实现自适应
  * vw表示相对于视图窗口的宽度，vh表示相对于视图窗口高度，vmin表示vw和vh中的较小值，vmax表示vw和vh中的较大值
  * 单位换算：如果要将px换算成vw单位，很简单，只要确定视图的窗口大小

## 深浅拷贝

**数组的浅拷贝：**比如数组，可以利用slice，contact方法返回一个新数组的特性来实现拷贝，但假如数组中嵌套了对象或者数组的话，使用contact方法克隆并不完整，只会拷贝对象和数组的引用，这样无论在新旧数组中进行修改，两者都会发生变化，这种就称为数组的浅拷贝

**深拷贝数组的方法：**

```js
var arr = ['old', 1, true, ['old1', 'old2'], {old: 1}]
var new_arr = JSON.parse(JSON.stringify(arr));
console.log(new_arr)
```

原理是通过json对象中的stringify可以把一个js对象序列化为一个JSON字符串，parse可以把json字符串反序列化为一个js对象，通过这两个方法也可以实现对象的深复制。但这个方法不能拷贝函数

**实现对象或数组的浅拷贝**

```js
var shallowCopy = function(obj){
	if(typeof obj !== 'object'){
		return
	}
	var newObj = obj instanceof Array ? [] : {};
	for(var key in obj){
		if(obj.hasOwnProperty(key)){
			newObj[key] = obj[key]
		}
	}
	return newObj;
}
```

**实现数组或对象的深拷贝**

```js
var deepCopy = function(obj){
	if(typeof obj !== 'obj'){ return }
	var newObj = obj instanceof Array ? [] : {};
	for(var key in obj){
		if(obj.hasOwnProperty(key)){
			newObj[key] = typeof obj[key] === 'object' ? deepCopy(obj[key]) : obj[key]
		}
	}
	return newObj
}
```

## 实现圆形可点击区域

1.客户端图像映射，带有可点击区域的一幅图像

2.css实现

3.JavaScript方法定义一个圆形的区域

## DOM事件中的target和currentTarget

**target：**事件触发的真实元素

**currentTarget：**事件绑定的元素

事件处理函数中的this指向是为currentTarget，由于事件冒泡，currentTarget和target有时是同一个元素有时候不是同一个元素；当事件是子元素触发时，target为子元素，currentTarget为绑定事件的元素，target为子元素；当事件是元素自身触发时，currentTarget和target是同一个元素。

## absolute与relative

absolute参照浏览器的左上角配合top,right,bottom,left属性进行定位，若没有设置则默认一句父级的坐标原始点为原始点。

relative：将父级的原始点设为原始点，没有父级则以body的原始点设置为原始点，配合位置值进行定位。当父级内有padding等css属性时，当前级的原始点则参照父级内容区的原始点进行定位。

## Vue事件总线

如果两个页面没有引入和被引入的关系，可以使用事件总线EventBus来通信而不需要使用类似Vuex这样的库来处理

事件总线像是所有组件共用相同的事件中心，若向该中心注册发送事件或接受事件，所有组件都可以上下平行地通知其他组件。

**使用方式：**

* 初始化：创建事件总线并将其导出，以便其他模块可以使用或监听它。可以通过两种方式来处理
  * 新建一个js文件
  * 直接在项目中的main.js初始化EventBus；这种方式初始化的EventBus是一个全局事件总线。
* 发送事件：假设两个Vue页面A和B通信，A页面在按钮上绑定了点击事件发送一条消息想通知B页面

```vue
<!-- A.vue -->
<template>
    <button @click="sendMsg()">-</button>
</template>

<script> 
import { EventBus } from "../event-bus.js";
export default {
  methods: {
    sendMsg() {
      EventBus.$emit("aMsg", '来自A页面的消息');
    }
  }
}; 
</script>
```

* 接收事件

```vue
<!-- IncrementCount.vue -->
<template>
  <p>{{msg}}</p>
</template>

<script> 
import { 
  EventBus 
} from "../event-bus.js";
export default {
  data(){
    return {
      msg: ''
    }
  },
  mounted() {
    EventBus.$on("aMsg", (msg) => {
      // A发送来的消息
      this.msg = msg;
    });
  }
};
</script>
```

**主要用到的方法**

```js
EventBus.$emit(channel:string,callback(payload1,...))
EventBus.$on(channel:string,callback(payload1,...))
```

问题：Vue是单页面应用，如果在一个页面刷新了之后，与之相关的EventBus会被移除；如果有反复操作的页面，EventBus在监听的时候就会触发很多次；

* 移除事件监听者：通常在Vue页面销毁时，同时移除EventBus事件监听

```js
import { 
  eventBus 
} from './event-bus.js'
EventBus.$off('aMsg', {})
```

可以使用 **EventBus.$off('aMsg')** 来移除应用内所有对此某个事件的监听。或者直接调用 **EventBus.$off()** 来移除所有事件频道，不需要添加任何参数 。

#### 全局EventBus

工作原理是发布/订阅方法，通常被称为Pub/Sub

```js
//创建全局EventBus
var EventBus = new Vue();
Object.defineProperties(Vue.prototype, {
  $bus: {
    get: function () {
      return EventBus
    }
  }
})
```

使用两个方法**$on和$emit**，一个用于创建发出的事件，另一个用于订阅接收

```js
var EventBus = new Vue();
this.$bus.$emit('nameOfEvent', { ... pass some event data ...});
this.$bus.$on('nameOfEvent',($event) => {
  // ...
})
```

```js
//可以在要发送的页面使用
this.$bus.$emit("sendMsg", '我是web秀');
//在要接收的页面使用
this.$bus.$on('updateMessage', function(value) {
  console.log(value); // 我是web秀
})
//移除事件监听
this.$bus.$off('sendMsg')
```

## 外边距折叠

块级元素的上下边距在某些情况下会合并起来，合并之后的大小为较大的margin。但浮动和绝对定位的元素的margin从不折叠。水平元素上不会发生外边距折叠















关于类型判断与比较

Vue双向绑定

懒加载(onscroll)


视口
连续20次执行sleep()函数，怎么实现
相邻组件通信

讲讲this

如果给你一段js的字符串代码，比如var a = 1; ....这样的代码，你怎么去执行他 

webpack怎么样 

node怎么样 

做过兼容吗

css的兼容做过吗 

跨域

jsonp原理 

前端安全 

事件委托

原型 

讲讲es6 

清除浮动有什么了解吗？ 

说一下常见的dom操作 

JS基本数据类型；Object属于？怎样检测数据类型？ 

CSS优先级算法；important知道吗？ 

项目怎么适配移动端？多说一点。移动端页面能不能缩小和放大该怎么办？ 

Viewport了解过吗？控制什么东西？meta里面可以设置什么东西呢？rem是什么？body的font-size怎么计算一个完美的值？ 

常用的字符串方法，数组方法。reduce作用，怎么传参。ES5之后有什么数组方法。 

11.commonJS,AMD,CMD,ES6模块思想你什么时候用到过？ 

12.JS继承；ES6的继承方法你了解过吗？例如Class 

13.你的项目当中有没有觉得有挑战的方面？ 

14.VUE了解多少？项目用的什么打包？webpack按需加载、热更新怎么配置？ 

15.import会返回什么样的东西？知道插槽吗？ 

16.动画了解过吗？CSS动画事件接触过吗？比如说动画结束后触发的事件 

17.promise了解嘛？简单说一下。promise.all/race介绍一下。 

18.axios和原生ajax的区别； 

19.async/await说一下 

20.target,currentTarget区别 

21.JS垃圾处理机制介绍一下，循环引用时怎么解决？ 

23.。 

24.VUE中，因为JS的性质，大数组里一个对象发生了改变，怎么保证数据的实时更新？ 

25.监听页面滚动怎么优化？（节流防抖） 

26.VUE组件通信 

27.vue-router原理；如何监听url改变？url怎么改变的？改变的哪一部分？例如hash有个#的改变，那history怎么改变呢？ 

28.vue的依赖跟踪(双向绑定原理)了解吗？你怎么知道数据改变了？set后那么多数据怎么就知道它触发了呢？怎么体现到dom上？

盒子模型，属性名称叫什么 

ES6新特性，然后问个别，比如let const的区别，箭头函数的区别 

vue router两种模式的区别，实现原理是什么，有什么区别，优缺点 

什么是MVVM，MVC和MVVM的区别 

后端传给你一个很大的数，在js里会出问题吗，为什么 

介绍一下你的两个项目 

Vue的实现原理是什么 

判断数组的方式，说到instanceof，什么是原型链，让你实现一个instanceof 

Promise的三种状态 

判断输出顺序，然后说为什么 

1.实现Promise.all 

2.用 Javascript 构造一个双向链表，并且实现它的插入和删除方法 

3.分饼干 

4.给定一个字符串如下，请统计字符串中出现最多的字母和次数 

5.实现instanceof 

让你概述下前端整个体系 

问了问webpack相关的 

让你设计一个通用的搜索组件，需要注意什么，只聊不写代码 

聊一聊你项目中的难点，你是怎么解决的

算法题：数组中找出最短子序列，它的和大于等于给定值 

智力题：64匹马，8个赛道，找出最快的4匹马问题 

跨域

addeventlistener

xss

盒子模型

手撕代码

1，实现百度搜索框

2，两个大正整数相加

1.react生命周期，虚拟dom，diff算法，keys，路由，setState原理（这个没答上来） 

2.ajax实现原理，以及和fetch的区别 

3.数组，和大于等于n的连续最短子序列（一开始忽略了连续，方向错导致没写完，让说了思路） 

4.设计一个类似百度搜索框那样随输随搜的，有哪些注意点 

5.跨域 

6.项目难点，怎么解决的 

7.说一说前端体系一面 （60min）

前端性能优化

https

Vue eventBus

动画 animation

跨域解决方案

coding 写一个 vue 计算器组件

coding 一段动画的实现

项目介绍

圣杯布局、双飞翼布局

手写 promise

情景题：双十一抢购设计倒计时

非对称加密发生在什么时候

DNS 劫持

跨域解决方案

Promise 设计模式

coding 把驼峰转下划线

coding 写一个 vue 父子组件双向绑定

coding 获取页面所有节点，并且输入 1-n 返回相应数量排序的节点，比如 div 数量最多，则输入 1，返回 div，如果不存在返回 null

webp png 区别

懒加载

动态表单

webpack

coding 排序，并计算复杂度

主要是三块考察 js css web development

js:
主要是两道题目，需求会不断变化

写一个字符串缩写函数
example: internationalization => i18n
alias => a3s
如果字符长度<4，则输出全部字符
num => num
并且可能输入一个句子，字符内容是只包含 a-z A-Z,其他均为分隔符
'-important-num-alias' => "-i6t-num-a3s"

debounce 防抖函数
需求 1:常规防抖
需求 2:要求在第一次调用时候，立即执行，后面调用的时候如果还在 wait 时间内，则不会调用，并且就算重复调用，也不会延时执行 2:要求在第一次调用时候，立即执行，后面调用的时候如果还在 wait 时间内，则不会调用，并且就算重复调用，也不会延时执行

example: debounce(func,wait) wait=500ms
0ms debounce 立即执行
100ms debouce 不执行
200ms debounce 不执行
700ms nothing happened
800ms debounce 立即执行

css：

position 有几个值以及作用

display:block | display:inline 区别以及作用

display:flex 相对于的值以及应用（主要是三栏布局然后问了下设置 flex-grow:1,flex-shrink:1，布局会发生什么变化）

web development:

cors

500KB of CSS, what will you do? what aspect do you think might be able to optimize?

三面 （60min）

jwt

设计验证方式

coding zombie game

1 小时内先做 5 道题目：

1.实现嵌套数组的扁平化，要求不能使用 JSON.stringify
输入:[1,[2,3,[4,5],[6]]
输出:[1,2,3,4,5,6]

实现一个实数的堆栈，使得其 push pop max 方法的时间复杂度为 O(1)

有一个整数二维数组，每行的元素个数不同，输出它的全排列，同一行的数互斥。要求不使用递归完成

4.实现一个函数，检查二叉树是否平衡。
平衡二叉树的定义如下：任意一个节点的左右子树高度差不超过 1。假设二叉树节点一共有 N 个节点，要求算法时间复杂度不超过 O(N)。
递归判断每个节点的左子树和右子树，遇到树深大于 1 的就算得到解。

接下来在开始面试：

项目介绍

eventLoop

其他忘记了

二面 （60min）

也是一样，先做题：

合并二叉树

奇偶链表

字串问题

开始面试：

对之前算法题询问，看是否有更优解

1.TS有了解？不了解 

2.除了js还有学过哪些语言？比如说一些静态语言？没有 

\3. 项目做过那些优化？有做指标吗？做过图片的优化和cdn，没有具体的指标。 

4.做过单元测试吗？没有 

5.原型链继承的原理以及内部实现？说了原理，内部实现是什么鬼？难道是说原型链的proto？ 

6.js的错误监控机制有了解吗？没有 

7.8.项目有什么亮点吗？回答动态权限管理，感觉不太满意 

9.还有什么问题吗？

前端优化方法。 

你了解过Vue，简单讲一下双向绑定原理。 

第一题是给一个多级嵌套的html节点结构，写一个算法用js对象表示（我采用的是递归算法）；

第二道是js文件互相之间有依赖关系，写一个算法能够推断出入口文件（最开始引入的文件），然后能够输出每层依赖的个数，并找出一个文件，删除它可以最大限度的减少文件依赖；（我这里想法是构造一颗依赖树。。然后面试官说我太复杂了）第三题是开放题，在一个网格中想一个随机制作障碍物的算法。

然后讲自己的算法思路，问了其它一些基础问题。。

上来先写一道算法题，大数相乘。

实现一个函数，可以展开任意层级（展开层级自定义）的数组 

输入一个json对象，里面定义了节点值及孩子节点，构造一个js对象对其进行描述。 

实现一个函数，可以实现数组的扁平化、

排序以及去掉最后的一个元素。 

一个数组，删除第一个重复的数。 

输入一个URL后发生了什么（尽可能详细） 

事件代理或事件委托/如何阻止事件冒泡 

一些位置计算相关的属性（如clientHeight等） 

JS节流与防抖 

浏览器内核有哪些 

H5及CSS3相关

H5新特性 

cookie、LocalStorage、SessionStorage、Session的区别 

cookie挂载在哪个对象上，怎么设置 

WebSocket相关 

canvas及SVG 

CSS3新特性 

动画与过渡效果 

清除浮动与BFC 

ES6常用的特性 

let与const的暂时性死区及为何增加这两个关键字 

继承的实现方式 

什么是闭包及其应用场景 

this的指向问题 

箭头函数及其应用场景 

Promise的原理及为什么用Promise 

js文件的异步加载（defer及async） 

数组对象push方法与cancat方法的区别 

bind、apply及call的区别 

对象深克隆 

什么是原型与原型链 

如何判断一个数据是否为数组 

Vue框架

双向绑定原理 

computed与watch的区别 

父子间组件通信及跨组件间通信 

路由的两种方式 

Vuex相关 

父子组件的数据加载与渲染的先后关系 

Vue的生命周期 

与React的区别 

其它

常见的设计模式 

前端工程化看法 

git的使用 

npm命令相关 

node相关 

webpack相关 

文件打包

.dom操作有哪些（回答了常用的，追问了querySelector）

代码题，promise实现延时（最开始说了思路，然后手动实现）

谈了this和改变指向性

算法与数据结构熟悉么，斐波那契数列求和（说了暴力和递归，感觉题目有点友善）

谈谈前端开发和后台的关系

在一个项目中如何合作

谈项目主要工作，难点，遇到的问题，怎么解决，印象最深的是什么，怎么协作的。

https和http（谈了区别，各自连接方式及相关拓展）

浏览器缓存

前端性能优化

页面生命周期了解么（第一反应是vue的，但不是问vue

generator，状态机的理解，应用

说一下position。（提到了重排和重绘）

说一下重排和重绘，position:absolut除了会产生重排还会产生什么？

css实现一个正方形（不会。。提示了padding-bottom/margin-bottom也不会）,那实现一个三角形吧。

用过弹性盒子吗？说一下flex:1这里面包含哪三个值，什么意思。（被面试官夸奖了，暗自窃喜haha）。

你提到了http，那你说一下304什么意思。（我在本子上写301 302 303 304面试官被我逗笑了。。。），那502什

么意思（网关通信代理的错误），笑着说。你是不是没分清502和504错误啊，（我下来查了一下，我说的对

的！），没事，知道5xx是服务器端错误就行。
那你知道http发展史吗？（不知道），那你知道http/3出了一个新东西吗？（不好意思，没关注它的发展史）
说一下js事件机制（event loop啊，说了一堆,提到了那几个微任务）。
你提到了promise,async await了，那你说说promise,async await和Generator生成器函数这些是怎么发展的吧，出现了一个肯定存在缺点解决什么问题，你说说。（说了一下promsie,async await的发展,其他的不知道了）
看你简历上提到了axios,那你说说你理解的axios,我看能不能说到我想听的那句话（啊，我，我，我怎么知道你要听到哪句话），没事，你就按着自己的说。（没想到），那你说说jquery封装的ajax和axios的区别。（就类似于原生js写的ajax和promsie的区别吧，说了一下）。（想起来了，你要听到的是不是axios返回promise对象，我之前写项目的时候有遇到过）,你知道fetch吗？你说说fetch吧，它和ajax axios有什么区别，fecth啊，额，记得一点点，说了一下，面试官说：其实axios我最想听你说它是promise对XHR的一个封装。
说说闭包。es6里面有闭包吗？
说说浅克隆深克隆。（不错，等会练个题，面试官一脸坏笑）
18.快排知道吗？（嗯，看过也练过，练过啊，那我就不问你了，时间复杂度是多少啊，说说思路吧）

19.写了一个编程题 

写了一个，面试官让优化，提示了map,给讲了一下用map怎么做，然后又问还能不能优化，提示了weekmap。没了解过，嗯，你下来可以试着写写。

var a = new Object()内存分配。 

JS遍历数组有哪些办法。

追问forEach和for in的区别

算法：数组去重。

null == undefined 的值是什么，为什么 

new 操作符的过程 

call apply 的区别 

讲一下闭包 

闭包打印 1-9 

splice、filter、join、split 用法 

数组转成字符串 

1000个button需要注册点击事件，怎么实现 

事件代理（委托）优缺点 

水平居中怎么实现 

 H5 C3 新特性 

css不兼容的情况有了解吗，怎么解决 

ES6 的东西知道哪些 

let const var的区别 

箭头函数与普通函数的区别 

手写一个数组去重 

排序算法，sort的用法解释一下 

splice 和 slice 的区别 

手撕代码 

浏览器缓存机制 

设计模式，用过哪些 
二进制转十进制，考虑溢出

二叉树：当前节点的值更新为当前节点所有子节点的值之和（递归和非递归）

项目中遇到的难题，怎么解决 (会针对这个重点问，不要给自己挖坑，我悔了 

CSS怎么画一个三角形 (get 

CSS怎么画扇形 (get) 

6.浏览器怎么实现异步 (没答上来 

7.JS实现动画的方法(get 

setTimeout、setInterval、requestAnimationFrame的区别 (get 

setTimeout具体实现过程（没答上来.....汗 

怎么实现鼠标拖拽 (get 

怎么实现跟随鼠标移动 (get 

写一下斐波那契数列吧

给我写了一段代码让我判断，但我什么都看不到，屏幕上只有hello world，慌了，面试官也不知道为啥，他把代码写在聊天框里让我看，我太紧张了看不出个所以然，我说要不咱们下一题吧 

面试官说你写一下二分查找吧 (get,也是写完要讲 

JS动画刷新频率 (没答上来 

盒模型 

Css三角形 

Css圆形 

说说vue数据双向绑定 

Ajax交互的过程 

说说BFC cookie，localStorage和sessonStorage区别 

sessionStrorage如果在同一个浏览器开两个窗口，数据可以用吗 

行内元素，块级元素 

闭包 

事件捕获和事件冒泡 

HTTP状态码有哪些？

如何清除浮动 

浮动是什么 

浮动对父级元素产生什么影响 

三栏布局的方式 

盒模型 

垂直水平居中的方式 

多行文本溢出省略--- 

基本数据类型 

有哪些方法判断变量的类型 

字符串的截取的方法 

substr和substring的区别 

es6了解 

es6新增的数组的方法--- 

遍历数组的方法 

说说forEach方法 

通过ID获取元素 

通过类名获取元素 

滚动条窗口初始设置为500，设置滚动的高度--- 

ajax核心对象--- 

jQuery添加一个新的封装方法--- 

jQuery隐藏元素 

jQuery显示 

jQuery把元素向左移动100px--- 

jQuery设置复选框选中--- 

jQuery设置或获取文本框的内容

vue用过吗 

说说如何获取后端的数据 

了解Java吗
盒子模型，可以通过什么属性控制get
CSP了解吗？get
用正则写个验证邮箱(太久没用忘了，看一下文档就能想起来，小姐姐听完笑了一下
浏览器的兼容性平时怎么解决(回答的不好，毕竟平时没怎么做过兼容性这块)
垂直居中的实现方式get
CSS的层叠性说一下get
浏览器的渲染过程说一下get

变量提升 

CSS3，H5哪些新特性，你最不常用的有哪些 

多栏布局为什么不经常用 

怎么避免变量提升//使用严格模式 

跨域方式知道哪些，用过哪些 

存储方式有哪些 cookie local storage sessionStorage 还有吗 

细问，cookie 可不可以不携带 

local storage 可不可以携带 ，怎么让他携带 

两者区别 

前端安全了解哪些 

浅拷贝深拷贝 

如何实现一个浅拷贝，循环，Object.assign 

VUE路由两种模式的区别 以及优缺点 

VUE nextTick 

SEO

一面： 

1.http状态码 

2.rem em px 

3.setState同步异步，怎么同步 

4.react性能优化 

5.前端性能优化 

6.react和传统html区别 

7.https工作原理 

8.防抖节流 

9.webpack的构建流程是什么 

10.深拷贝浅拷贝 浅拷贝常用方法 

11.amd cmd 

12.跨域nginx 

13.垂直居中 

14.scss for循环 

 

二面： 

1.两个同源tab页面如何通信 

2.错误捕获 

3.你画我猜思路 

4.浏览器实时监控后端数据 

\1. 实现斐波纳西数列（当时脑子有点乱，写了挺长时间，写完了自己都还不知道还是面试官提醒的），第一次用递归，问了一下算法复杂度（时间，空间）。然后改进一下，用循环，也问了算法复杂度。 

\2. 尾递归。（我没印象了） 

\3. css选择器。 

\4. 如何实现垂直居中。 

\5. css有哪几种定位方式，在页面上实现一个一直不动的定位怎么实现。 

\6. 用promise实现一下sleep。（尝试了一下，然后放弃了，介绍了简单思路）。 

\7. es6的新特性。 

\8. 如何开启多线程。（我脑子一热讲了异步编程，讲完了面试官提示我要讲的是多线程。。。） 

\9. 解释一下async awite底层原理。 

\10. 状态码（问到了303、307、308，我刚好不记得了。。。） 

\11. http怎么建立连接（讲了1.0、1.1、2.0） 

\12. 应该还有一些，不记得了 

解释一下js中原型链以及继承的工作方式 

介绍一下 this 的工作方式 

闭包是什么 

闭包的应用有哪些 

函数柯里化的原理 

有应用到函数式编程的库有哪些（lodash） 

谈谈你对 es6 中 Promise 的理解 

Promise.all 和 Promise.race 的区别以及他们的实现方式 

什么是同源策略 

跨域怎么解决 

jsonp的内部机制 

script 标签的 async 和 defer 加与不加有什么区别 

vue 的组件间通信方式 

vue 中双向绑定的原理（刚刚说完了通信方式我以为问的是 v-model，说完 v-model 之后让我说了响应式原理） 

前端安全了解哪些？（xss、csrf） 

ddos 了解吗？ 

说说你知道的前端优化方案（聊到了 webpack 构建优化的 happypack） 

除了 happypack 之外还有什么其他的构建优化吗 

时间差不多了，说说你最近在看的前端知识点吧（说了 vue.$nextTick 的原理）

1、https的具体实现原理是什么，是怎么实现安全传输的？ 

2、如何实现js里的new的功能，一行代码描述； 

3、h5有没有用过，web worker是做什么的？ 

4、函数节流和函数防抖的原理，怎么实现？ 

5、怎么实现Promise的功能？ 

6、webgl用过吗？ 

如何适应手机端页面？ 

9、闭包的优缺点是什么？ 

项目中怎么做图片压缩，减小打包后的项目大小？

事件委托 

如何阻止事件冒泡 

js是单线程还是多线程？如何实现异步 

promise是微任务还是宏任务 

promise执行多个的话怎么写？这个问题不是很理解，我就答了Promise.all 

Promise.all有一个失败的话会怎么样 

前端安全？xss和csrf 

csrf是怎么窃取用户数据的 

异步加载script?async和defer的区别 

一个输入表单页面，要转到其他页面再回来，如何保存页面的输入表单数据以便继续输入？

项目里边比较有技术亮点或者是实现难度的技术有哪些？ 

轮播图是通过延伸的js还是通过vue？ 

轮播图支持循环的轮播嘛？能从第九张直接跳到第一张嘛？ 

如果不用插件自己手写一个轮播插件需要考虑哪些方面？ 

对应难点的实现方案？ 

有办法通过css控制图片之间的距离嘛？ 

css3的transform和translate有了解过吗？ 

用的vue版本是什么？ 

vue3和vue2有什么区别？ 

有手写过vue自定义指令嘛？指令是什么？v-xxx？指令怎么使用的？ 

子组件和父组件怎么通信？ 

vue里的provider什么意思？ 

插槽有什么作用？v-slot出现想解决什么问题？ 

路由有几种模式？hash？history?hash路由怎么切换不同的页面？通过什么监听还是通过什么 

有封装过vue的组件嘛 

如果去设计一个高可用高扩展性的组件不仅仅是ui。。不了解直接跳过 

es6proxy干嘛的。数据验证怎么做？和es5里的object.defineproperty有什么区别 

有手写过原生js吗比如说？ 

熟悉Google的后台调试工具是什么东西？？？ 

cookie和session的区别 

cookie存在是为了解决什么问题？常见的用途？内容大小限制是多少？和localstorage、sessionstorage有什么区别 

cookie是区分路径还是区分域名的？ 

localstorage不想让它一直有效怎么处理？在里面塞一个值，取的时候对比一下时间，如果发现时间已经过去了，就把他remove掉 

jquery链式调用是怎么实现的？每次调用return this，return$对象 

typescript了解过吗、 

如何实现一个jsonp的跨域请求？加个callback 

调试面板performance用过吗application这些

浏览器缓存？强缓存、协商缓存  		

输入url到渲染页面的过程？最后返回的不是html文件会怎么做？  		

​				实现div水平垂直居中  		

​				同源策略？能请求到另一个页面的数据吗？  		

​				web安全了解吗？  		

​				会jquery吗？  		

​				数组常用方法说一些  		

​				call和apply方法的区别？用过吗？  		

​				变量作用域问题？函数嵌套作用域访问？  		

​				get和post区别？用过吗？

行内元素，相对于它的父级水平垂直居中，css怎么写  

  对于一个行内元素，设置它的margin会有什么表现，为什么它是可行的  

  margin给行内元素设置还是给父级元素设置  

  行内元素设置margin会有位置的改变嘛  

  块级元素200px，行内元素10px，左右设置多少  

  块级元素，父级也是块级元素，水平垂直居中怎么写css





















































# 面试题第二部分：代码运行

```js
var a = 10;
function test(){
	a = 100;
	console.log(a);
	console.log(this.a);
	var a;
	console.log(a);
}
test()
```

答案：100 10 100；在node中100 undefined 100

```js
(function () {
	var a = b = 3
})()
console.log(a,b);
```

答案：undefined 3

原因：a在函数作用域内

```js
for(var i = 1;i<=3;i++){
	setTimeout(function(){
		console.log(i);
	},0)
}
```

答案：4,4,4

原因：主线程内一次只能执行一个任务，主线程遇到异步时会将异步操作放到等待队列中，然后主线程会继续执行，然后才调用异步函数

```js
function fun(n){
	console.log(n);
	var n = 456;
	console.log(n);
}
var n = 123;
fun(n);


```

答案：123 456

```js
var n = 123;
function f1(){
	console.log(n);
}
function f2(){
	var n = 456;
	f1();
}
f2();
console.log(n);
```

答案：123 123

原因：f1的作用域在全局

```js
var length = 100;
function f1(){
	console.log(this.length);
}
var obj = {
	x:10,
	f2:function(f1){
		f1();
		arguments[0]();
	},
}
obj.f2(f1,1)
```

答案：100 2

```js
function f(){
	console.log(this.a);
}
var obj = {
	a:2,
	f:f
}
var f2 = obj.f;
var a = "hello";
f2();

function f(){
	console.log(this.a);
}
var obj = {
	a:2,
	f:f
}
var f2 = obj.f();
var a = "hello";
f2();
//此答案为2，注意区别
```

答案：hello

```js
function f(s){
	console.log(this.a,s);
	return this.a + s;
}
var obj = {
	a:2
}
var f2 = function(){
	return f.apply(obj,arguments);
}
var b = f2(3)
console.log(b);
```

答案：2,3,5

```js
function b(){
	console.log(a);
	var a = 10;
	function a(){}
	a = 100;
	console.log(a);
}
b();
```

答案：[Function:a] 100

```js
(function d(num) {
	console.log(num);
	var num = 10;
})(100)
```

答案：100

```js
(function e(num) {
	console.log(num);
	var num = 10;
	function num(){};
})(100)
```

答案：[Function:num]

```js
function m(){
	console.log(a1);
	console.log(a2);
	console.log(b1);
	console.log(b2);
	if(false){
		function b1(){}
		var a1 = 100;
	}
	if(true){
		function b2(){};
		var a2 = 10;
	}
	console.log(a1);
	console.log(a2); 
	console.log(b1);
	console.log(b2);
}
```

答案：undefined undefined undefined undefined 10 undefined undefined undefined

```js
(function f(num){
	function num(){}
	console.log(num);
	var num = 10;
	console.log(num);
})(100)
```

答案：[Function:num] 10

### 4:四45





