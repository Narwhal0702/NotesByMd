# 前端面试题

## 1

关于这5个问题，有三个是与ES6相关，两个是与vue相关，其中vue实现数据绑定的原理设计到了vue的底层原理，而vuex则是vue的核心插件。

### 关于ES6中的Symbol，他为了解决什么问题(详见ES6_Symbol)

* ES5的对象属性名都是字符串，容易造成属性名的冲突。Symbol类型表示独一无二的值。通过Symbol函数生成。他通过Symbol函数生成。它主要解决的问题也就是属性名冲突的问题，因为每一个Symbol值都是不相等的。所以他可以作为标识符用于对象的属性名。
* 这就对一个对象由多个模块构成的情况非常有用，能防止某一个键不小心被改写或覆盖。
* 补充：Symbol值作为对象属性名时不能使用点运算符。因为点运算符后面总是字符串，所以会导致某属性的属性名是字符串而不是Symbol值，这样使用方括号内的Symbol值就无法访问到了。Symbol作为属性名时需要使用[]包裹

### 关于map和set(详见ES6_Set和Map数据结构)

* set类似于数组，但是成员都是唯一的，没有重复
  * 附：向Set加入值时不会发生类型转换，所以"5"和5是两个不同的值，在Set中NaN等于自身，精确相等运算符NaN不等于自身
* mapMap结构实现了值-值的对应，JavaScript的对象本质是键值对的集合(Hash结构)，但是只能用字符串作为键。Map类似于对象也是键值对的集合，但是键的范围不限于字符串，各种类型的值都可以当做键。
* WeakSet
  * 结构与Set类似，也是不重复的值的集合。
  * 成员只能是对象，WeakSet中的对象都是弱引用，即垃圾回收机制不考虑WeakSet对该对象的引用
* WeakMap
  * 与map结构类似，也用于生成键值对的集合
  * WeakMap只接受对象作为键名(null除外)，键名所指向的对象不计入垃圾回收机制

### vue实现数据绑定的原理

* 实现数据绑定主要是实现两个方面的功能：数据导致视图变化，视图变化导致数据变化。后者就是监听视图的事件，然后唉回调函数中改变数据。终重点是数据变化时如何改变视图
  * 思路：通过object.defineProperty()来对数据的属性设置一个set函数，设置后当数据改变时set函数就会被调用，我们就可以里面进行视图更新操作。

### 关于defineProperty的缺陷，以及怎么解决这个问题

使用Proxy解决该问题

* 修改属性默认的特性，该方法接收三个参数，分别是属性所在的对象，属性的名字和一个描述符对象。描述符对象的属性必须是configurable,enumerable,writable和value。设置其中的一个或多个值，可以修改对应的特性值
* 把configurable属性设为false，表示不能从对象中删除属性。如果对这个属性调用delete，在严格模式下回导致错误。一旦把属性定义为不可配置的，就不能把它再变回可配置了。此时再调用该方法修改writable之外的特性都会导致错误
* 他的缺陷：
  * Object.defineProperty无法监控到数组下标的变化，导致通过数组下标添加元素，不能实时响应；
  * Object.defineProperty只能劫持对象的属性，从而需要对每个对象，每个属性进行遍历，如果，属性值是对象，还需要深度遍历。Proxy可以劫持整个对象，并返回一个新的对象。
  * Proxy不仅可以代理对象，还可以代理数组。还可以代理动态增加的属性。
* 有关于vue
  * vue3.0之前的版本都是使用该方法来实现数据的响应式，通过设定对象属性getter/setter方法来监听数据的变化，同时getter也用于依赖收集，而setter在数据变更时通知订阅者更新视图
  * 缺陷：
    * 无法检测到对象属性的新增或删除：由于js的动态性，可以为对象追加新的属性或者删除其中某个属性，这点对经过Object.defineProperty方法建立的响应式对象来说，只能追踪对象已有数据是否被修改，无法追踪新增属性和删除属性，这就需要另外处理
    * 不能监听数组的变化

### vuex的工作流程

简单地来说当遇到多个组件共享状态时，单向数据流的间接性很容易被破坏。比如多个视图依赖于同一状态，不同视图的行为需要变更同一状态。

可以将组件的共享状态抽取出来，以一个全局单例模式管理。通过定义和隔离状态管理中的各种概念，并通过强制规则维持视图和状态间的独立性，我们的代码将会变得更结构化且易维护。

就是创建一个store，然后通过在Vue组件中访问this.$store。



---

## 2

### 虚拟DOM

### symbol的用途

主要是作为标识符用于对象的属性名，保证不会出现相同的属性名，这对于一个对象由多个模块构成的情况非常有用；其次可以保证switch语句按照设计的方式工作



### 节流 防抖

### 箭头函数和匿名函数的区别（会不会发生函数声明提升？）

### 准确判断一个对象是不是数组

---

### 3

### css单位

### 垃圾收集

### 动画

### 不兼容ES6怎么办

### 清除浮动 

---





# 面试题第二部分：代码运行

### 1

```js
var a = 10;
function test(){
	a = 100;
	console.log(a);
	console.log(this.a);
	var a;
	console.log(a);
}
test()
```

答案：100 10 100；在node中100 undefined 100

```js
(function () {
	var a = b = 3
})()
console.log(a,b);
```

答案：undefined 3

原因：a在函数作用域内

```js
for(var i = 1;i<=3;i++){
	setTimeout(function(){
		console.log(i);
	},0)
}
```

答案：4,4,4

原因：主线程内一次只能执行一个任务，主线程遇到异步时会将异步操作放到等待队列中，然后主线程会继续执行，然后才调用异步函数

```js
function fun(n){
	console.log(n);
	var n = 456;
	console.log(n);
}
var n = 123;
fun(n);


```

答案：123 456

```js
var n = 123;
function f1(){
	console.log(n);
}
function f2(){
	var n = 456;
	f1();
}
f2();
console.log(n);
```

答案：123 123

原因：f1的作用域在全局

### 2:46







# 关于HTML的面试

### http1.0，2.0及其新特性

* 是对http1.0的更新，提升了访问速度，允许多路复用，在http1中同一时间内针对同一域名下的请求有数量限制；2.0会将传输信息分割，进行二进制编码，这样可以加快传输速度

### http的请求类型，请求字段

### https(过程)，怎么防止中间人攻击，原理、

* http: 超文本传输协议，是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效
* https: 是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。主要作用是建立一个安全通道，用来确保数组的传输，保证网站的真实性
* 区别：http传输的数据时明文的，https协议是由SSL+HTTP协议构建的可进行加密传输，身份认证的协议网络，想必之下更安全，但https协议的费用较高
* https的工作原理：客户使用https访问服务器，服务器建立ssl连接，服务器接到请求后会将网站的整数传输给客户端。然后双方开始协商一致安全等级，建立会话密匙，通过网站的公钥来加密会话密钥，并传送给网站。web服务器通过自己的私钥解密出会话密钥，通过会话密钥加密与客户端之间的通信。
* https协议的优缺点：保证数据传输过程中数据不被窃取改变。缺点是比较费时，会增加数据开销，ssl证书也比较贵

### TCP三次握手四次挥手(为什么要三次握手，在什么情况下会四次挥手)

* 客户端向服务器端发出请求链接，第一次握手，客户端给服务端发送一个带SYN标识的数据包，然后服务端确认自己可以收到这个数据包，然后会给客户端发送数报文段，客户端确认可以收到服务端发送的数据，进行第三次握手，发送给服务端数据让服务端确认客户端收到了自己发送的数据包

### osi七层模型

### http报文内容

### cookie和session的区别，其他验证方法

* cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递。保存用户登录状态。例如将用户id存储于一个cookie内，这样当用户下次访问该页面时就不需要重新登录了；cookie还可以设置过期时间，当超过时间期限后，cookie就会自动消失；

### TCP与UDP协议的区别

### DNS解析原理

### get与post区别 

* get和post请求传参的长度不是http规定的而是因为浏览器和web服务器限制了URI(统一资源标识符)的长度，不同浏览器和Web服务器的限制最大长度不同
* 在缓存方面的区别
  * get请求类似于查找的过程，用户获取数据可以不用每次都和数据库连接，所以可以使用缓存。(相比于post更适合)
  * post做的一般都是删除和修改的工作，必须和数据库交互，所以不能使用缓存。

### 状态码（301与302区别，304缓存的原理）

### 缓存(强缓存/协商缓存字段/缓存优先级/浏览器缓存)

### XSS及CROS攻击及预防措施

### 什么是同源策略，如何实现跨域访问

### 从输入一个url到页面渲染的全过程

* DNS解析:将域名地址解析为ip地址
* TCP连接，三次握手
* 发送请求
* 接收响应
* 渲染页面
* 
* 断开连接

