# 面试题重要内容



  

### 浏览器输入url地址到页面渲染的过程

**1、输入url后客户端发送域名给DNS服务器解析为ip地址，然后将IP地址返回给浏览器**

​	TCP/IP协议根据IP地址进行访问的，所以需要将域名请求为ip地址

**2、客户端根据IP地址连接到Web服务器**

一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（HTTP请求默认端口为80）建立一个TCP套接字连接。

**3、三次握手建立TCP连接后发送HTTP请求**

通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据4部分组成。

​	**浏览器与服务器的交互过程**

​		1）首先浏览器利用tcp协议通过三次握手与服务器建立连接

　　http请求包括header和body。header中包括请求的方式（get和post）、请求的协议 （http、https、			ftp）、请求的地址ip、缓存cookie。body中有请求的内容。

　　2）浏览器根据解析到的IP地址和端口号发起http的get请求.

　　3）服务器接收到http请求之后，开始搜索html页面，并使用http返回响应报文

　　4）若状态码为200显示响应成功，浏览器接收到返回的html页面之后，开始进行页面的渲染

**4、服务器接受到请求并返回HTTP响应报文**

Web服务器解析请求，定位请求资源，然后执行请求分析，查找数据库等操作后并返回一个HTTP响应。服务器将资源复本写到TCP套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据4部分组成。

**5、四次挥手释放连接TCP连接**

若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接;

若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求;

**6、客户端浏览器解析HTML内容**

客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。

​		**浏览器页面渲染过程**

　　1）浏览器根据深度遍历的方式把html节点遍历成dom 树

　　2）将css解析成CSS DOM树

　　3）将dom树和CSS DOM树构造成render树

　　4）JS根据得到的render树 计算所有节点在屏幕中的位置，进行布局（回流）

　　5）遍历render树并调用硬件API绘制所有节点（重绘）





### 跨域

协议，域名，端口有一个不同

### 实现元素的水平居中

* 父元素相对定位，子元素绝对定位









































# 前端面试题

## 1

关于这5个问题，有三个是与ES6相关，两个是与vue相关，其中vue实现数据绑定的原理设计到了vue的底层原理，而vuex则是vue的核心插件。

### 关于ES6中的Symbol，他为了解决什么问题(详见ES6_Symbol)

* ES5的对象属性名都是字符串，容易造成属性名的冲突。Symbol类型表示独一无二的值。通过Symbol函数生成。他通过Symbol函数生成。它主要解决的问题也就是属性名冲突的问题，因为每一个Symbol值都是不相等的。所以他可以作为标识符用于对象的属性名。
* 这就对一个对象由多个模块构成的情况非常有用，能防止某一个键不小心被改写或覆盖。
* 补充：Symbol值作为对象属性名时不能使用点运算符。因为点运算符后面总是字符串，所以会导致某属性的属性名是字符串而不是Symbol值，这样使用方括号内的Symbol值就无法访问到了。Symbol作为属性名时需要使用[]包裹

### 关于map和set(详见ES6_Set和Map数据结构)

* set类似于数组，但是成员都是唯一的，没有重复
  * 附：向Set加入值时不会发生类型转换，所以"5"和5是两个不同的值，在Set中NaN等于自身，精确相等运算符NaN不等于自身
* mapMap结构实现了值-值的对应，JavaScript的对象本质是键值对的集合(Hash结构)，但是只能用字符串作为键。Map类似于对象也是键值对的集合，但是键的范围不限于字符串，各种类型的值都可以当做键。
* WeakSet
  * 结构与Set类似，也是不重复的值的集合。
  * 成员只能是对象，WeakSet中的对象都是弱引用，即垃圾回收机制不考虑WeakSet对该对象的引用
* WeakMap
  * 与map结构类似，也用于生成键值对的集合
  * WeakMap只接受对象作为键名(null除外)，键名所指向的对象不计入垃圾回收机制

### vue实现数据绑定的原理

* 实现数据绑定主要是实现两个方面的功能：数据导致视图变化，视图变化导致数据变化。后者就是监听视图的事件，然后唉回调函数中改变数据。终重点是数据变化时如何改变视图
  * 思路：通过object.defineProperty()来对数据的属性设置一个set函数，设置后当数据改变时set函数就会被调用，我们就可以里面进行视图更新操作。

### 关于defineProperty的缺陷，以及怎么解决这个问题

使用Proxy解决该问题

* 修改属性默认的特性，该方法接收三个参数，分别是属性所在的对象，属性的名字和一个描述符对象。描述符对象的属性必须是configurable,enumerable,writable和value。设置其中的一个或多个值，可以修改对应的特性值
* 把configurable属性设为false，表示不能从对象中删除属性。如果对这个属性调用delete，在严格模式下回导致错误。一旦把属性定义为不可配置的，就不能把它再变回可配置了。此时再调用该方法修改writable之外的特性都会导致错误
* 他的缺陷：
  * Object.defineProperty无法监控到数组下标的变化，导致通过数组下标添加元素，不能实时响应；
  * Object.defineProperty只能劫持对象的属性，从而需要对每个对象，每个属性进行遍历，如果，属性值是对象，还需要深度遍历。Proxy可以劫持整个对象，并返回一个新的对象。
  * Proxy不仅可以代理对象，还可以代理数组。还可以代理动态增加的属性。
* 有关于vue
  * vue3.0之前的版本都是使用该方法来实现数据的响应式，通过设定对象属性getter/setter方法来监听数据的变化，同时getter也用于依赖收集，而setter在数据变更时通知订阅者更新视图
  * 缺陷：
    * 无法检测到对象属性的新增或删除：由于js的动态性，可以为对象追加新的属性或者删除其中某个属性，这点对经过Object.defineProperty方法建立的响应式对象来说，只能追踪对象已有数据是否被修改，无法追踪新增属性和删除属性，这就需要另外处理
    * 不能监听数组的变化

### vuex的工作流程

简单地来说当遇到多个组件共享状态时，单向数据流的间接性很容易被破坏。比如多个视图依赖于同一状态，不同视图的行为需要变更同一状态。

可以将组件的共享状态抽取出来，以一个全局单例模式管理。通过定义和隔离状态管理中的各种概念，并通过强制规则维持视图和状态间的独立性，我们的代码将会变得更结构化且易维护。

就是创建一个store，然后通过在Vue组件中访问this.$store。



---

## 2

### 虚拟DOM

### symbol的用途

主要是作为标识符用于对象的属性名，保证不会出现相同的属性名，这对于一个对象由多个模块构成的情况非常有用；其次可以保证switch语句按照设计的方式工作



### 节流 防抖

### 箭头函数和匿名函数的区别（会不会发生函数声明提升？）

### 准确判断一个对象是不是数组

* 通过一个Array.prototype.isPrototypeOf(obj)方法，判断Array是不是在obj的原型链中，如果是则返回true，不是则返回false
* 通过构造函数：obj instanceof Array
  * typeof 和instanceof区别：
* 根据对象的class属性，跨原型链调用toString方法
* Array.isArray()

---

## 3

### css单位

* px：像素
* em：1em为字体当前尺寸，2em为字体尺寸的两倍、
* ex：一个ex是一个字体的x-height(x-height通常是字体尺寸的一般)
* %：百分比
* rem：相对与根节点html的字体大小来计算
* vw：视窗宽度：1vw等于视窗宽度的1%
* vh：视窗高度：1vh等于视窗高度的1%

### 垃圾收集

### 动画

### 不兼容ES6怎么办

安装babel并将其引入到script中

### 清除浮动 

浮动是css中的一个属性float，块级元素可以通过该属性实现左右浮动，目的是让div实现类似表格行和列横竖排布，但是浮动时其他块元素会占用原来位置(对后面元素产生影响)，也就是说浮动会脱离文档流将其他的元素挤走

清除浮动方法：

* 使用带clear属性的空元素：在浮动元素后使用一个空元素如\<div class="clear"\>\</div\>，并在CSS中赋予.clear{clear:both;}属性即可清理浮动。亦可使用\<br class="clear" /\>或\<hr class="clear" />来进行清理。
* 使用css的overflow属性：给浮动元素的容器添加overflow:hidden;或overflow:auto;可以清除浮动，在添加overflow属性后，浮动元素又回到了容器层，把容器高度撑起，达到了清理浮动的效果。
* 给浮动的元素容器添加浮动：给浮动元素的容器也添加上浮动属性即可清除内部浮动，但是这样会使其整体浮动，影响布局，不推荐使用
* 使用相邻元素处理：什么都不做，给浮动元素后面的元素添加clear属性
* 使用css的:after伪元素：给浮动元素的容器添加一个clearfix的class，然后给这个class添加一个:after伪元素实现元素末尾添加一个看不见的块元素（Block element）清理浮动

---

### 跨域

跨域是指一个域下的文档或脚本试图去请求另一个域下的资源https://segmentfault.com/a/1190000011145364

* 广义的跨域：
  * 资源跳转：a链接，重定向，表单提交
  * 资源嵌入：link,script,img,frame等dom标签，还有样式中的文件外链
  * 脚本请求：js发起的ajax请求，dom和js对象的跨域操作
* 同源策略：指协议+域名+端口三者相同，即使两个不同的域名指向同一个ip地址也不是同源
  * 同源策略限制以下几种行为：Cookie，LocalStorage和IndexDB无法获取；DOM和js对象无法获得；ajax请求不能发送
  * 常见场景：
    * 同一域名，不同文件或路径
    * 同一域名不同端口
    * 同一域名不同协议
    * 域名和域名对应相同ip
    * 主域相同子域不同
    * 不同域名

### 解决方案

* 通过jsonp跨域：通常为了减轻web服务器的负载，我们把js、css，img等静态资源分离到另一台独立域名的服务器上，在html页面中再通过相应的标签从不同域名下加载静态资源，而被浏览器允许，基于此原理，我们可以通过动态创建script，再请求一个带参网址实现跨域通信

```html
//原生实现
<script>
    var script = document.createElement('script')
    script.type = 'text/javascript'
    //传参一个回调函数名给后端,方便后端返回时执行这个在前端定义的回调函数
    script.src = 'http://www.domain2.com:8080/login?user=admin&callback=handleCallback'
    document.head.appendChild(script)
    //回调执行函数
    function handleCallback(res){
        //...
    }
</script>
```

```js
//vue实现
this.$http.jsonp('http://www.domain2.com:8080/login', {
    params: {},
    jsonp: 'handleCallback'
}).then((res) => {
    console.log(res); 
})
```

缺点：只能实现get一种请求

* document.domain+iframe跨域：实现原理：两个页面都通过js强制设置document.domain为基础主域，就实现了同域
  * 仅限主域相同，子域不同的跨域应用场景
    * 父窗口：http://www.domain.com/a.html
    * 子窗口：http://child.domain.com/b.html

```html
//父窗口
<iframe id="iframe" src="http://child.domain.com/b.html"></iframe>
<script>
    document.domain = 'domain.com';
    var user = 'admin';
</script>
//子窗口
<script>
    document.domain = 'domain.com';
    // 获取父窗口中变量
    alert('get js data from parent ---> ' + window.parent.user);
</script>
```

* location.hash+iframe跨域：a欲与b跨域相互通信，通过中间页c来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。
* window.name+iframe跨域：name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）

* 跨域资源共享(CORS)

```js
//在ajax中设置
xhr.withCredentials = true;
```

* Nginx，Nodejs代理跨域









### 响应式布局常见解决方案

* 基础概念：
  * 像素：是网页布局的基础，一个像素表示了计算机屏幕所能显示的最小区域，像素分为css像素和物理像素。在js或css代码中使用的px单位就是css像素，物理像素也称设备像素，只与设备的硬件密度相关，任何设备的物理像素都是固定的
  * 视口：只浏览器显示内容的屏幕区域
    * 布局视口
      * 布局视口定义了pc网页在移动端的默认布局行为，也就是说在不设置网页的viewport的情况下，pc端的网页默认会以布局视口为基准，在移动端进行展示
    * 视觉视口
      * 视觉视口表示浏览器内看到的网站的显示区域，用户可以通过缩放来查看网页的显示内容，从而改变视觉视口。
    * 理想视口
      * 在移动设备中就是指设备的分辨率。换句话说，理想视口或者说分辨率就是给定设备物理像素的情况下，最佳的“布局视口”。

* px和视口
  * 1个css像素可以表示为物理像素/分辨率，如在iphone6移动端一个css像素为0.75px而在pc端则为2px
* 媒体查询
  * 在css文件中，1px所表示的物理像素的大小是不同的，因此通过一套样式，是无法实现各端的自适应，所以给每一种设备设置一套不同的样式来实现自适应效果

```css
@media screen and (max-width: 960px){
    body{
      background-color:#FF6699
    }
}

@media screen and (max-width: 768px){
    body{
      background-color:#00FF66;
    }
}
```

缺点：在浏览器大小改变时，需要改变的样式太多，那么多套样式代码会很繁琐

* 百分比
  * 子元素height和width的百分比：子元素的height或width中使用百分比，是相对于子元素的直接父元素，width相对于父元素的width，height相对于父元素的height。
  * top和bottom 、left和right：子元素的top和bottom如果设置百分比，则相对于直接非static定位(默认定位)的父元素的高度，同样，子元素的left和right如果设置百分比，则相对于直接非static定位(默认定位的)父元素的宽度
  * padding：子元素的padding如果设置百分比，不论是垂直方向或者是水平方向，都相对于直接父亲元素的width，而与父元素的height无关。子元素的初始宽高为0，通过padding可以将父元素撑大，说明padding不论宽高，如果设置成百分比都相对于父元素的width
  * margin：跟padding一样，margin也是如此，子元素的margin如果设置成百分比，不论是垂直方向还是水平方向，都相对于直接父元素的width。
  * border-radius：border-radius不一样，如果设置border-radius为百分比，则是相对于自身的宽度
  * 缺点：
    * 计算困难，如果我们要定义一个元素的宽度和高度，按照设计稿，必须换算成百分比单位
    * 各个属性中如果使用百分比，相对父元素的属性并不是唯一的

* 通过rem来实现响应式布局
  * rem单位都是相对于根元素html的font-size来决定大小的,根元素的font-size相当于提供了一个基准，当页面的size发生变化时，只需要改变font-size的值，那么以rem为固定单位的元素的大小也会发生响应的变化。如果通过rem来实现响应式的布局，只需要根据视图容器的大小，动态的改变font-size即可
  * 可通过webpack实现一些单位之间的转换
  * 缺点：在响应式布局中，必须通过js来动态控制根元素font-size的大小，具有一定的耦合性，且font-size的代码要放在样式之前
* 通过vw/vh实现自适应
  * vw表示相对于视图窗口的宽度，vh表示相对于视图窗口高度，vmin表示vw和vh中的较小值，vmax表示vw和vh中的较大值
  * 单位换算：如果要将px换算成vw单位，很简单，只要确定视图的窗口大小

---

## 5

### 深浅拷贝

数组的浅拷贝：比如数组，可以利用slice，contact方法返回一个新数组的特性来实现拷贝，但假如数组中嵌套了对象或者数组的话，使用contact方法克隆并不完整，只会拷贝对象和数组的引用，这样无论在新旧数组中进行修改，两者都会发生变化，这种就称为数组的浅拷贝



深拷贝数组的方法：

```js
var arr = ['old', 1, true, ['old1', 'old2'], {old: 1}]
var new_arr = JSON.parse(JSON.stringify(arr));
console.log(new_arr)
```

原理是通过json对象中的stringify可以把一个js对象序列化为一个JSON字符串，parse可以把json字符串反序列化为一个js对象，通过这两个方法也可以实现对象的深复制。**但这个方法不能拷贝函数**



**实现对象或数组的浅拷贝**

```js
var shallowCopy = function(obj){
	if(typeof obj !== 'object'){
		return
	}
	var newObj = obj instanceof Array ? [] : {};
	for(var key in obj){
		if(obj.hasOwnProperty(key)){
			newObj[key] = obj[key]
		}
	}
	return newObj;
}
```

**实现数组或对象的深拷贝**

```js
var deepCopy = function(obj){
	if(typeof obj !== 'obj'){ return }
	var newObj = obj instanceof Array ? [] : {};
	for(var key in obj){
		if(obj.hasOwnProperty(key)){
			newObj[key] = typeof obj[key] === 'object' ? deepCopy(obj[key]) : obj[key]
		}
	}
	return newObj
}
```







# 面试题第二部分：代码运行

### 1

```js
var a = 10;
function test(){
	a = 100;
	console.log(a);
	console.log(this.a);
	var a;
	console.log(a);
}
test()
```

答案：100 10 100；在node中100 undefined 100

```js
(function () {
	var a = b = 3
})()
console.log(a,b);
```

答案：undefined 3

原因：a在函数作用域内

```js
for(var i = 1;i<=3;i++){
	setTimeout(function(){
		console.log(i);
	},0)
}
```

答案：4,4,4

原因：主线程内一次只能执行一个任务，主线程遇到异步时会将异步操作放到等待队列中，然后主线程会继续执行，然后才调用异步函数

```js
function fun(n){
	console.log(n);
	var n = 456;
	console.log(n);
}
var n = 123;
fun(n);


```

答案：123 456

```js
var n = 123;
function f1(){
	console.log(n);
}
function f2(){
	var n = 456;
	f1();
}
f2();
console.log(n);
```

答案：123 123

原因：f1的作用域在全局

### 2

```js
var length = 100;
function f1(){
	console.log(this.length);
}
var obj = {
	x:10,
	f2:function(f1){
		f1();
		arguments[0]();
	},
}
obj.f2(f1,1)
```

答案：100 2

```js
function f(){
	console.log(this.a);
}
var obj = {
	a:2,
	f:f
}
var f2 = obj.f;
var a = "hello";
f2();

function f(){
	console.log(this.a);
}
var obj = {
	a:2,
	f:f
}
var f2 = obj.f();
var a = "hello";
f2();
//此答案为2，注意区别
```

答案：hello

```js
function f(s){
	console.log(this.a,s);
	return this.a + s;
}
var obj = {
	a:2
}
var f2 = function(){
	return f.apply(obj,arguments);
}
var b = f2(3)
console.log(b);
```

答案：2,3,5

### 3

```js
function b(){
	console.log(a);
	var a = 10;
	function a(){}
	a = 100;
	console.log(a);
}
b();
```

答案：[Function:a] 100

```js
(function d(num) {
	console.log(num);
	var num = 10;
})(100)
```

答案：100

```js
(function e(num) {
	console.log(num);
	var num = 10;
	function num(){};
})(100)
```

答案：[Function:num]

```js
function m(){
	console.log(a1);
	console.log(a2);
	console.log(b1);
	console.log(b2);
	if(false){
		function b1(){}
		var a1 = 100;
	}
	if(true){
		function b2(){};
		var a2 = 10;
	}
	console.log(a1);
	console.log(a2); 
	console.log(b1);
	console.log(b2);
}
```

答案：undefined undefined undefined undefined 10 undefined undefined undefined

```js
(function f(num){
	function num(){}
	console.log(num);
	var num = 10;
	console.log(num);
})(100)
```

答案：[Function:num] 10

### 4:四45





